## 싱글톤 패턴과 정적 클래스

프로그램 전역에서 사용되는 유일한 클래스를 만드는 것은 싱글톤 패턴을 이용하는 것과 정적 클래스를 이용하는 두 가지 방법이 있다.

### 싱글톤 패턴이란?

싱글톤 패턴은 객체 인스턴스가 오로지 한 개만 생성 되도록 설계하는 패턴이다. 하지만 싱글톤 패턴의 구현에는 문제점이 있다. 바로 멀티쓰레드 환경에서 싱글톤이 보장되지 않는다는 것이다.

```java
public class Singleton {
  private static Singleton singletonObject;

  private Singleton() {
  }

  public static Singleton getInstance() {
    if(singletonObject == null) { //B
      singletonObject = new Singleton(); //A
    }
    return singletonObject;
  }
}
```

쓰레드A와 B가 동시에 요청을 보냈다고 하자. A가 조건문을 통과해 인스턴스를 생성하기 전 만약 B도 통과한다면 각각 다른 인스턴스가 생길 가능성이 존재한다. 이를 해결하기 위해선 어떻게 해야할까?

1. synchronized 키워드

```java
public synchronized static Singleton getInstance() {
    if(singletonObject == null) {
      singletonObject = new Singleton();
    }
    return singletonObject;
}
```

해당 키워드를 사용하면 현재 메소드를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드가 메소드에 접근할 수 없도록 막아준다. 현재 진행중인 쓰레드가 메소드를 완료할 때 다른 쓰레드가 진입 가능하다. 하지만 이 코드에도 문제점이 있다. 만약 인스턴스가 존재한다면 더 이상 필요가 없게 된다. 메소드를 실행할 때마다 lock이 걸리게 되어 리소스 낭비가 발생한다.

2. Double Checked Locking(DCL)

위 방법을 해결하기 위해 DCL이라는 방법이 제안되었다.

- synchronized 시점 지연
- private static volatile 인스턴스
- 생성자를 private

```java
public class Singleton {
  private static volatile Singleton singletonObject;

  private Singleton() {
  }

  public static Singleton getInstance() {
    if(singletonObject == null) {
      synchronized(Singleton.class) {
        if(singletonObject == null) {
            singletonObject = new Singleton();
        }
      }
    }
    return singletonObject;
  }
}
```

현재 getInstance() 메소드를 호출할 때마다 인스턴스가 있을 때는 synchronized 블록이 스킵된다. 그러면 즉시 인스턴스만 반환하게 되어 리소스 낭비를 없앨 수 있다. 그리고 이 때 클래스 변수에 정의해 놓은 인스턴스를 volatile이라는 키워드를 이용하여 쓰기와 읽기 모두 메인 메모리에서 하도록 만들어 시간차를 극복할 수 있다.

3. Bill Pugh Solution(Initialization on demand holder idiom)

이 방법은 싱글톤을 구현할 때 권장되어지는 방법 중 하나이다. Holder 역할을 하는 private static 클래스를 이용한다.

- static inner class 인스턴스
- 생성자를 private

```java
public class Singleton {

  private Singleton() {
  }

  private static class SingletonHolder {
    private static final Singleton SETTINGS = new Singleton();
  }

  public static Singleton getInstance() {
    return SingletonHolder.SETTINGS;
  }
}
```

최초로 ClassLoader에 의해서 로드 될 때 내부로 synchronized가 실행된다. 그래서 명시적으로 synchronized를 이용하지 않고 동일한 효과를 낼 수 있다. SingletonHolder 클래스는 static이므로 메소드가 실행될 때 JVM의 static initializer에 의해 초기화 되고 메모리에 올라가게 된다. 따라서 thread-safe와 lazy-loading을 둘 다 만족하는 싱글톤 구현이 가능하다. 하지만 해당 코드의 문제점은 클라이언트가 임의로 리플렉션과 직렬화를 통해 싱글톤을 파괴할 수 있다는 점이다.

4. Enum

```java
public enum Singleton {

    INSTANCE;
}
```

enum은 생성자를 private으로 갖게 만들고 상수만 가지는 클래스이기 때문에 싱글톤의 성질을 갖게 된다. 이렇게 구현하게 되면 Bill Pugh의 방법과는 다르게 리플렉션과 직렬화로 깨뜨릴 수 없게 된다. 하지만 싱글톤을 해제할 때의 번거로움과 enum 외의 클래스를 상속한다면 사용할 수 없다는 단점이 있다.

### 정적 클래스는 뭐가 다를까?

```java
public class Singleton {

    private Singleton() {
    }

    //static method
    public static void setMap() {
        ...
    }
}
```

정적 메소드만 갖고 있는 클래스를 정적 클래스라고 한다. static 메소드들은 클래스 초기화시에 메소드 영역에 등록되어 프로그램이 끝날 때 해제된다. 따라서 애플리케이션 내에서 싱글톤 패턴과 마찬가지로 전역적으로 사용할 수 있고 인스턴스를 따로 생성하지 않기 때문에 유일성을 보장받을 수 있다.

### 싱글톤과 정적 클래스는 언제 쓸까?

- 싱글톤 패턴
  - 상속받아서 사용 가능하다.
  - 메소드 파라미터로 사용 가능하다.

따라서 애플리케이션 내에서 객체처럼 사용하고 싶을 때 혹은 인스턴스를 생성할 때 리소스가 많이 드는 경우 권장된다.

- 정적 클래스
  - 객체 생성을 하지 않는다.(효율성)

정적 클래스는 객체처럼 사용할 수는 없지만 유틸 클래스처럼 객체 성질이 필요 없을 때, 다형성이나 상속이 필요 없는 클래스의 경우 권장된다.
