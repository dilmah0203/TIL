## 자바와 객체지향

### 객체 지향의 4대 특성

1. 추상화
2. 상속
3. 다형성
4. 캡슐화

### 1. 추상화 

객체는 유일무이한 사물이며 클래스는 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념이다. 자바는 객체 지향의 추상화를 class 키워드를 통해 구현한다. 

클래스를 이용해 객체를 만들었다는 것을 강조할 때는 객체라는 표현보다는 인스턴스라는 표현을 쓴다. 클래스를 객체의 설계도라고 설명하는 말은 바로 이런 과정에서 나왔다.

객체 지향 프로그래밍을 할 때 클래스를 먼저 설계하게 되는데, 추상화와 무슨 관련이 있을까? 사람이라는 클래스를 설계한다고 했을 때 사람 클래스를 만들기 위해 사람 객체들이 가진 공통된 특성을 찾게 된다. 혈액형과 직업 취미와 같은 속성과 일하다 운전하다와 같은 메소드를 가질 수 있다.

사람 클래스가 사람 객체들의 모든 특성을 나열해야 될까? 여기서 또 하나의 개념이 나온다. 바로 애플리케이션 경계(컨텍스트)다. 예를 들어 병원 애플리케이션을 만들고 있다면 사람은 환자를 의미하는 구체적인 이름으로 바꿀 수 있으며 클래스 설계도 달라진다.

정리하자면 추상화는 **구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것**이라고 할 수 있다.

### 2. 상속: 재사용 + 확장

객체 지향의 상속은 영어 단어를 그대로 옮기면서 생긴 오해라고 할 수 있다. 객체 지향의 상속은 상속이 아닌 재사용과 확장으로 이해하는 것이 맞다.

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Extends1.png)

다음 그림은 상속 관계가 아니다. 동물은 포유류의 부모가 아니며 역시 고래의 부모가 포유류일 수는 없다. 객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미이다. 그래서 부모-자식 클래스라는 표현보다는 상위-하위 클래스 또는 슈퍼-서브 클래스라고 표현하는 것이 옳다. 그리고 상위 클래스 쪽으로 갈수록 추상화, 일반화 되었다고 말하며, 하위 클래스 쪽으로 갈수록 구체화, 특수화됐다고 말한다.

**상속은 is a 관계를 만족해야 한다?**

is a 관계는 객체와 클래스의 관계로 오해될 소지가 많다. 그렇다면 상속 관계의 더 명확한 표현은 무엇일까? is a kind of 관계이며 다음과 같이 정리할 수 있다.

- 상속 관계 : 하위 클래스 is a kind of 상위 클래스
- 하위 클래스는 상위 클래스의 한 분류다

**인터페이스는 어떤 관계를 나타내는 것일까?**

- 인터페이스 : 구현 클래스 is able to 인터페이스
- 구현 클래스는 인터페이스 할 수 있다

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/Extends2.png)


인터페이스는 be able to, 즉 무엇을 할 수 있는 이라는 표현 형태로 만드는 것이 좋다. 상위 클래스는 하위 클래스에서 특성(속성과 메소드)을 상속해주고, 인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제하게 된다.

### 3. 다형성: 사용편의성

객체 지향에서 다형성이라고 하면 오버라이딩과 오버로딩이라고 할 수 있다.

- 오버라이딩 : 같은 메소드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의하는 것
- 오버로딩 : 같은 메소드 이름, 다른 인자 목록으로 다수의 메소드를 중복 정의하는 것

두 숫자를 더해서 반환하는 add() 메소드가 있다고 해보자. 오버로딩이 지원되지 않는 언어에서는 add라고 하는 메소드명을 이미 사용했기에 인자가 다를 경우 다른 메소드명을 사용해야 한다. 오버라이딩의 경우 하위 클래스가 재정의한 메소드를 알아서 호출해 줌으로써 형변환이나 instanceof 연산자를 써서 하위 클래스가 무엇인지 신경 쓰지 않아도 된다. 자바는 이 두 개념을 통해 다형성과 사용편의성을 제공한다.

### 4. 캡슐화: 정보 은닉

자바에서 정보 은닉이란 접근 제어자가 있다.

![img3](https://github.com/dilmah0203/TIL/blob/main/Image/%EC%A0%91%EA%B7%BC%EC%A0%9C%EC%96%B4%EC%9E%90.png)

접근 제어자는 그림과 같이 절대 단순하지 않다. 특히 객체 멤버에 대한 접근인가, 정적 멤버에 대한 접근인가에 따라 생각할 것이 많아진다.

- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.

public 정적 속성인 pubSt의 경우라면 각 위치별 객체 멤버 메서드에서 접근할 수 있는 방법은 무려 세 가지나 된다.

![img4](https://github.com/dilmah0203/TIL/blob/main/Image/%EC%A0%91%EA%B7%BC%EC%A0%9C%EC%96%B4%EC%9E%902.png)

정적 멤버인 경우 클래스명.정적멤버 형식으로 접근해야 하는 이유가 있다. 바로 일관된 형식으로 접근하기 위해서다. 그리고 객체를 생성한 경우에는 객체참조변수명.정적멤버 형태로도 접근할수도 있다. 정적 멤버는 해당 클래스의 모든 객체가 같은 값을 가지는 경우에 쓸 수 있다.

- 사람 클래스의 인구
- 고양이의 다리 개수

사람, 고양이로 접근하는 것이 홍길동, 키티 형식으로 접근하는 것보다 권장된다. 즉, 정적 멤버에 접근할 때는 클래스명.정적멤버 형식으로 접근하는 것이 좋다. 메모리의 물리적 접근에 따른 이유도 있다.
