## 제네릭(Generic)

제네릭이란 **컴파일 타임**에 타입을 체크함으로써 코드의 안전성을 높여주고, 데이터 형식에 의존하지 않고 하나의 값이 다른 데이터 타입을 가질 수 있다.

```java
List<T> //T는 타입 매개변수
```

```java
List<String> stringList = new ArrayList<String>(); //String은 매개변수화된 타입
```

### 제네릭은 왜 사용할까?

1. **컴파일 타임에 강력한 타입 검사**

- 제네릭 미사용

```java
List stringList = new ArrayList<>();
stringList.add("juseon");
stringList.add(3);
//String 타입으로 캐스팅 할 경우 문제 발생, Runtime Error
String result = (String) stringList.get(0) + (String) stringList.get(1); 
```

- 제네릭 사용

```java
List<String> stringList = new ArrayList<>();
stringList.add("juseon");
stringList.add(3); //Compile Error
```

제네릭을 사용한 경우 List의 타입 매개변수를 String으로 지정하면 타입을 컴파일러가 알게 된다. 따라서 실행 시키면 의도한 대로 동작한다는 것을 보장받을 수 있다.

2. **캐스팅(타입 변환) 제거**

- 제네릭 미사용

```java
List stringList = new ArrayList<>();
stringList.add("juseon");
String result = (String) stringList.get(0);
```

- 제네릭 사용

```java
List<String> stringList = new ArrayList<>();
stringList.add("juseon");
String result = stringList.get(0);
```

제네릭을 사용하지 않을 경우, List에서 값을 꺼낼 때 매번 타입 변환을 하게되고 프로그램 성능에 안 좋은 영향을 줄 수 있다. 반면 제네릭을 사용하면 List에 저장되는 요소를 String 타입으로 제한했기 때문에 캐스팅이 필요하지 않다.

### 배열 vs 제네릭

- 배열

```java
Object[] objectArray = new Integer[1];
```

배열은 Integer가 Object의 하위 타입이면 Integer 배열도 Object 배열의 하위 타입이 성립된다. 이러한 특징을 공변이라고 하는데, 공변이란 타입 B가 타입 A의 하위 타입일 때 B[]는 A[]의 하위 타입이 된다. 즉, 함께 변한다.

- 제네릭

```java
List<Object> objectList = new ArrayList<Integer>(); //Compile error
```

제네릭에서는 Integer가 Object의 하위 타입이더라도 컴파일 오류를 낸다. 이와 같은 특징을 무공변이라 하며 서로의 하위 타입도 상위 타입도 될 수 없다.

### 제네릭 타입과 제네릭 메소드

```java
public class NoodleCategory<T> {

  public T t; //T는 t의 데이터 타입

  public void set(T t) {
    this. t = t;
  }

  public T get() {
    return t;
  }

  public <T> void printClassName(T t) {
    System.out.println("클래스 필드에 정의된 타입 = " + this.t.getClass().getName()); //패키지명.Noodle
    System.out.println("제네릭 메소드에 정의된 타입 = " + t.getClass().getName()); //패키지명.Pasta
  }
}
```

```java
NoodleCategory<Noodle> noodleCategory = new NoodleCategory<>();
noodleCategory.set(new Noodle());
noodleCatehory.printClassName(new Pasta());
```

제네릭 타입은 타입을 파라미터로 가지는 클래스와 인터페이스를 말한다. 제네릭 메소드는 메소드의 선언부에 제네릭 타입이 선언된 형식이다. 타입 매개 변수의 범위가 메소드 내로 한정된다는 것이 제네릭 타입과의 차이점이다. 클래스에 선언된 타입 매개변수와 제네릭 메소드에 해당하는 printClassName에 선언된 타입 매개변수는 같은 T지만 서로 다르다.

### 제네릭 타입제한의 필요성

NoodleCategory 클래스는 현재 타입 매개변수에는 모든 종류의 타입을 저장할 수 있다. 그렇다면 해당 클래스 타입을 Coke라고 선언한다면 클래스 필드에 Coke도 저장할 수 있게된다. 만약 Noodle 타입만 저장하고 싶을 경우는 어떻게 할까?

```java
public class NoodleCategory<T extends Noodle> {

  public T t; //T는 t의 데이터 타입

  public void set(T t) {
    this. t = t;
  }

  public T get() {
    return t;
  }
}
```

이를 해결하기 위해서는 생성한 NoodleCategory 클래스의 타입에 T extends Noodle를 붙여주면 된다. Noodle과 Noodle을 상속한 타입만 올 수 있게된다.

```java
NoodleCategory<Ramen> ramenNoodleCategory = new NoodleCategory<>();

NoodleCategory<Coke> ramenNoodleCategory = new NoodleCategory<>(); //Compile Error
```

### 와일드 카드

와일드카드는 정해지지 않은 unknown type이기 때문에 모든 타입에 대해 호출이 가능하다.제네릭에서 와일드 카드의 형태는 총 세가지가 있다.

1. <?> Unbounded Wildcards : 모든 타입이 가능

2. <? extends Noodle> Upper Bounded Wildcards : Noodle과 Noodle의 하위 타입


3. <? super Noodle> Lower Bounded Wildcards : Noodle과 Noodle의 상위 타입

```java
public class Category<T> {

  public T t;

  public void set(T t) {
    this. t = t;
  }

  public T get() {
    return t;
  }
}
```

```java
public class CategoryHelper {

    public void popNoodle(Category<? extends Noodle> category) {
        Noodle noodle = category.get();

        category.set(new Noodle()); //컴파일 오휴
    }

    public void pushNoodle(Category<? super Noodle> category) {
        category.set(new Noodle());

        Noodle noodle = category.get();
    }
}
```

popNoodle() 메소드는 Category 타입 매개변수를 Noodle 타입으로 상한 제한을 하였는데, 이렇게 하게 되면 최상위 타입인 Noodle만 들어오기 때문에 해당 타입을 안전하게 가지고 올 수 있다. 하지만 메소드에서 저장을 하려고 할 경우 Category의 매개변수화 된 타입이 Pasta라면, set 메소드에 상위타입인 Noodle이 들어올지 Pasta가 들어올지 알 수 없다. 즉 하위타입에 상위 타입을 대입할 위험이 있기 때문에 컴파일 오류가 뜨게 된다.

pushNoodle() 메소드는 Category 타입 매개변수를 Noodle 타입으로 하한 제한을 하였기 때문에 Noodle이거나 Noodle의 상위 타입만 올 수 있다. 하지만 메소드에서 Category를 꺼내 Noodle로 변환할 경우 Noodle보다 상위 타입이 꺼내질 수도 있기 때문에 컴파일 오류가 나게 된다.

> 언제 무엇을 써야할까?

**PECS(Producer-Extends, Consumer-Super) 공식**

생성을 하는 곳에서는 extends를 쓰고 소비를 하는 곳은 super를 사용해야 한다.

```java
public class NoodleCategory<E> {

    private List<E> list = new ArrayList<>();

    public void pushAll(Collection<? extends E> box) {
        for(E e: box) {
            list.add(e);
        }
    }
}
```

pushAll() 메소드는 상한 제한을 하였기 때문에 타입을 안전하게 가지고 올 수 있다. 따라서 타입을 가지고 와서 인스턴스 list에 넣어 원소 생성이 가능하다. 이렇게 무언가를 생성하는 경우 extends를 사용하는 것이 적절하다.

```java
public class NoodleCategory<E> {

    private List<E> list = new ArrayList<>();

    public void popAll(Commection<? super E> box) {
        box.addAll(list);
        list.clear();
    }
}
```

반면 super는 하한 경계이기 때문에 안전하게 값을 저장할 수 있다. 즉 인스턴스 list의 원소를 소비해서 box에 원소를 추가하고 있다.

<br>

참고

[우아한Tech 제네릭](https://www.youtube.com/watch?v=w5AKXDBW1gQ&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=57&t=478s)

https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html(https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html)
