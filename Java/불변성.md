## 불변성(Immutability)이란

불변성이란 변하지 않는 성질을 의미한다. 객체가 불변하다는 것은 객체 생성 이후 **상태를 바꿀 수 없는 것**을 뜻한다. 여기서 바꿀 수 없다는 것은 Heap 영역에서 그 객체가 가리키고 있는 데이터 자체의 변화가 불가능 함을 의미한다. Java의 대표적인 불변 객체는 String이 있다.

예로 `String name = "ju seon";`에서 `name = "lee ju seon";`으로 name이 가리키는 주소의 변경은 가능하다. 여기서 name은 값을 바꿔준 것처럼 보이지만 String이 `"lee ju seon"`을 가지고 있는 새로운 객체를 참조하고 있는 것이다.

## 불변성이 왜 중요할까?

멀티 쓰레드 환경에서 동기화 문제가 발생하는 이유는 공유 자원에 동시에 쓰기(Write) 때문이다. 하지만 공유 자원을 불변하게 생성하면 생성 시점 이후 해당 객체의 상태는 변경할 수 없으므로, 쓰레드 간 서로의 간섭에 의해 생길 수 있는 동기화 문제를 고려하지 않아도 된다. (Thread safe하다.)

하지만 상태 변경이 필요한 경우에는 매번 새로운 객체를 생성해야 하고, 새로운 객체를 많이 생성하는 경우 성능 문제가 발생할 수 있다.

### Java에서 불변 객체를 생성하는 법

**필드가 모두 primitive type인 경우**

```java
public class Car {

    private final String name;
    private final int color;

    public Car(String name, int color) {
        this.name = name;
        this.color = color;
    }
}
```

setter가 없고, 필드에 대해 final을 설정하였다면 해당 객체 Car는 불변 객체가 된다.

**필드에 reference type이 있는 경우**

```java
public final class ImmutableReference {

    private final int num;
    private final Amount amount;

    public ImmutableReference(int num, Amount amount) {
        this.num = num;
        this.amount = amount;
    }

    public int getNum() {
        return num;
    }

    public Amount getAmount() {
        return amount;
    }
}
```

Amountn 필드에 단순히 final만 붙이면 불변 객체가 되는 것처럼 보인다.

```java
public class Amount {

    private int value;

    public Amount(int value) {
        this.value = value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    @Override
    public String toString() {
        return "amount=" + value;
    }
}
```

```java
@DisplayName("불변 객체 테스트")
class ImmutableReferenceTest {

    @Test
    void immutableTest() {
        Amount amount = new Amount(10);

        ImmutableReference immutableReference = new ImmutableReference(10, amount);
        System.out.println(immutableReference.getAmount()); //10

        Amount newAmount = immutableReference.getAmount();
        newAmount.setCount(50);

        System.out.println(immutableReference.getAmount()); //50
    }
}
```

ImmutableReference 클래스로 부터 amount를 가져온 이후에 외부에서 amount의 값을 변경했다. 하지만 변경된 값이 newAmount에만 적용된 것이 아닌 ImmutableReference에도 적용된다. 불변객체의 필드로 선언한 Amount 객체의 참조가 외부와 연결되어 있기 때문이다. 그렇기 때문에 안전한 객체를 만드려면 불변객체 내부의 필드 또한 불변하게 만들어야 한다.

**Collection이 필드로 있는 경우**

```java
public final class ImmutableCollection {

    private final int num;
    private final List<Integer> list;

    public ImmutableCollection(int num, List<Integer> list) {
        this.num = num;
        this.list = list;
    }

    public int getNum() {
        return num;
    }

    public List<Integer> getList() {
        return list;
    }
}
```

```java
@DisplayName("불변 객체 Collection 테스트")
class ImmutableCollectionTest {

    @Test
    void immutableTest() {
        List<Integer> list = new ArrayList<>();
        list.add(1);

        ImmutableCollection immutableCollection = new ImmutableCollection(10, list);
        System.out.println(immutableCollection.getList()); //[1]

        List<Integer> newList = immutableCollection.getList(); 
        newList.add(2);

        System.out.println(immutableCollection.getList()); //[1,2]
    }
}
```

unmodifiable Collection은 해당 Collection을 read-only로 사용하도록 하기 때문에 add()와 같은 수정을 시도할 시에는 UnsupportedOperationException이 발생하게 된다.

```java
List<String> list = new ArrayList<>();
list.add("B");
list = Collections.unmodifiableList(list);
list.add("C"); // UnsupportedOperationException 발생
```

<br>

참고

https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html
