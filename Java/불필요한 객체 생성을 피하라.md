## 불필요한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 낫습니다. 재사용하면 더 빠르고, 불변객체는 항상 재사용할 수 있습니다.

### 문자열 객체 생성

자바에서 String을 new로 생성하게 되면 항상 새로운 겍체를 만들게 됩니다. 다음과 같이 String 객체를 생성하는 것이 올바릅니다. ([String과 new String](https://github.com/dilmah0203/TIL/blob/main/Java/String%EA%B3%BC%20new%20String.md))

```java
String s = "example";
```

문자열 리터럴을 재사용할 수 있기 때문에, 해당 자바 가상 머신 안에 같은 문자열 리터럴이 존재하면 그 리터럴을 재사용합니다.

### 정적 팩토리 메소드 사용하기

자바 9에서 `Deprecated`된 `Boolean(String)` 생성자 대신 `Boolean.valueOf(String)` 같은 정적 팩토리 메소드를 사용할 수 있습니다. 생성자는 호출할 때마다 새로운 객체를 만들지만, 팩토리 메소드는 그렇지 않습니다.

### 생성 비용이 비싼 객체

만드는 데 메모리나 시간이 오래걸리는 생성 비용이 비싼 객체가 반복해서 호출된다면 캐싱하여 재사용할 수 있습니다. 

다음은 정규표현식을 활용한 예입니다. 문자열이 로마 숫자를 표현하는지 확인하는 코드입니다.

```java
static boolean isRomanNumeralSlow(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
            + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

`String.matches()`는 정규표현식으로 문자열 형태를 확인하는 방법이긴 하지만 성능이 중요한 상황에서 반복적으로 사용하기에 적절하지 않습니다. 

`String.matches()`는 내부적으로 `Pattern` 객체를 만들어 쓰는데 그 객체를 만들려면 정규표현식으로 유한 상태 머신로 컴파일 하는 과정이 필요합니다. 즉 비싼 객체입니다. 성능을 개선하려면 `Pattern` 인스턴스를 직접 생성해 캐싱해두고 재사용하는 것이 좋습니다.

```java
public class RomanNumerals {

    private static final Pattern ROMAN = Pattern.compile(
            "^(?=.)M*(C[MD]|D?C{0,3})"
                    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```

하지만 위의 코드도 문제가 있는데, 만약 `isRomanNumeral()` 메소드가 호출되지 않는다면 `ROMAN` 필드는 필요없이 만든셈이 됩니다.

### 어댑터

객체가 불변이라면 재사용해도 안전함이 명확합니다. 하지만 어떤 경우에는 분명하지 않은 경우가 있습니다. 어댑터를 예로 들면, 어댑터는 실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체입니다. 

예로 `Map` 인터페이스의 `keySet()` 메소드는 `Map` 객체 안의 키 전부를 담은 `Set`을 반환합니다. `keySet()`을 호출할 때마다 새로운 객체가 나올 것 같지만 사실 같은 객체를 리턴하기 때문에 리턴 받은 `Set` 객체를 변경하면, 결국 `Map` 객체도 변경하게 됩니다.

```java
Map<String, Integer> map = new HashMap<>();
map.put("apple", 3);
map.put("grape", 5);

Set<String> fruit = map.keySet();
Set<String> fruit2 = map.keySet();
fruit.remove("apple");
System.out.println(fruit2.size());  //1
System.out.println(map.size());   //1
```

### 오토박싱

불필요한 객체를 만들어내는 또 다른 예로 오토박싱이 있습니다. 오토박싱은 프로그래머가 `primitive type`과 해당하는 `래퍼 클래스` 객체 간에 자동으로 상호 변환해주는 기술입니다.

오토박싱은 `primitive type`과 그에 대응하는 `래퍼 클래스`간의 구분을 흐려주지만, 완전히 없애주진 않습니다.

```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }

    return sum;
}
```

위 코드는 `sum` 변수의 타입을 `Long`으로 만들었기 때문에 불필요한 `Long` 객체를 2의 31 제곱개 만큼 만들게 됩니다. 타입을 `primitive` 타입으로 바꾸면 성능이 약 10배 이상 차이납니다.

**불필요한 오토박싱을 피하려면 래퍼 클래스 보다는 primitive type을 사용해야 합니다.**

하지만 방어적인 복사(데이터를 복제해 새로운 객체를 생성하여 작업을 수행하는 것)를 해야 하는 경우에는 객체를 재사용하면 심각한 버그와 보안성 문제가 생길 수 있습니다.
