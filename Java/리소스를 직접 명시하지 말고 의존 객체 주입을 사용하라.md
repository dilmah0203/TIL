## 리소스를 직접 명시하지 말고 의존 객체 주입을 사용하라

### static 유틸리티 클래스

많은 클래스는 하나 이상의 리소스에 의존한다. 예로 맞춤법 검사기 `SpellChecker`는 `dictionary`를 사용하고, 이를 의존성이라고 부른다. 이때 `SpellChecker`를 다음과 같이 구현할 수 있습니다.

```java
public class SpellChecker {

    //부적절한 static 유틸리티 클래스 사용 예
    private static final Lexicon dictionary = new KoreanDictionary();

    private SpellChecker() {
    }

    public static boolean isValid(String word) {
        throw new UnsupportedOperationException();
    }

    public static List<String> suggestions(String typo) {
        throw new UnsupportedOperationException();
    }
}
```

```java
SpellChecker.isValid("hello");
```

아래의 코드를 보면 한국어 사전으로 고정이 되어있습니다. 다른 사전으로 이용하기 위해서는 코드를 변경해야 하므로 유연하지 못하고 테스트하기 어렵습니다.

```java
private static final Lexicon dictionary = new KoreanDictionary();
```

### 싱글톤으로 구현하기

```java
public class SpellChecker {

    private final Lexicon dictionary = new KoreanDictionary();

    private SpellChecker() {
    }

    public static final SpellChecker INSTANCE = new SpellChecker() {
    };

    public boolean isValid(String word) {
        throw new UnsupportedOperationException();
    }

    public List<String> suggestions(String typo) {
        throw new UnsupportedOperationException();
    }
}
```

```java
SpellChecker.INSTANCE.isValid("hello"); //싱글톤 인스턴스를 통해 메소드 사용
```

사전을 하나만 사용할꺼라면 위와 같은 구현도 만족스러울 수 있겠지만, 실제로는 사전이 언어별로 따로 있고 테스트를 위해 테스트용 사전을 사용하고 싶을 수도 있습니다.

**어떤 클래스가 사용하는 리소스에 따라 동작을 달리 해야 하는 경우에는 static 유틸리티 클래스와 싱글톤을 사용하는 것은 적합하지 않습니다.** 이러한 요구 사항을 만족하기 위해 **인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방법**이 있습니다.

### 적절한 구현

```java
public class SpellChecker {

    private final Lexicon dictionary;

    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }

    public boolean isValid(String word) {
        throw new UnsupportedOperationException();
    }

    public List<String> suggestions(String typo) {
        throw new UnsupportedOperationException();
    }
}
```

```java
//한국어 사전을 사용하는 경우
Lexicon koreanDictionary = new KoreanDictionary();
SpellChecker spellChecker = new SpellChecker(koreanDictionary);

//영어 사전을 사용하는 경우
Lexicon englishDictionary = new EnglishDictionary();
SpellChecker spellChecker2 = new SpellChecker(englishDictionary);

//클라이언트 코드에서 각각의 사전을 주입하여 사용
boolean isValid1 = spellChecker.isValid("안녕하세요");
boolean isValid2 = spellChecker2.isValid("hello");
```

위와 같은 의존성 주입은 `생성자`, `정적 팩토리 메소드`, 그리고 `빌더`에도 적용할 수 있습니다.

**정적 팩토리 메소드 예시**

```java
public class SpellChecker {

    private final Lexicon dictionary;

    public SpellChecker(Lexicon dictionary) {
        this.dictionary = dictionary;
    }

    public static SpellChecker createForKorean() {
        Lexicon koreanDictionary = new KoreanDictionary();
        return new SpellChecker(koreanDictionary);
    }
}
```

```java
SpellChecker spellChecker = SpellChecker.createForKorean();
```

**빌더 패턴 예시**

```java
public class SpellChecker {

    private final Lexicon dictionary;

    public SpellChecker(Builder builder) {
        this.dictionary = builder.dictionary;
    }

    public static class Builder {

        private Lexicon dictionary;

        public Builder createDictionary(Lexicon dictionary) {
            this.dictionary = dictionary;
            return this;
        }

        public SpellChecker build() {
            return new SpellChecker(this);
        }
    }
}
```

```java
Lexicon koreanDictionary = new KoreanDictionary();
SpellChecker spellChecker = new SpellChecker.Builder()
    .createDictionary(koreanDictionary)
    .build();
```

이 패턴의 변형으로, 생성자에 리소스의 팩토리를 전달하는 방법도 있습니다. 팩토리란 호출 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체로, 자바8에 들어온 `Supplier<T>` 인터페이스가 팩토리를 표현한 예로 `Supplier<T>`를 인자로 받는 메소드는 보통 `bounded wildcard type`으로 입력을 제한해야 합니다.

```java
public class SpellChecker {

    private final Lexicon dictionary;

    public SpellChecker(Supplier<Lexicon> dictionary) {
        this.dictionary = dictionary.get();
    }

    public boolean isValid(String word) {
        throw new UnsupportedOperationException();
    }

    public static void main(String[] args) {
        Lexicon lexicon = new KoreanDictionary();
        SpellChecker checker = new SpellChecker(new Supplier<Lexicon>() {
            @Override
            public Lexicon get() {
                return lexicon;
            }
        });
        checker.isValid("hello");
    }
}
```

