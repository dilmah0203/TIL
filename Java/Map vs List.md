# 💡 **Map vs List**


- **Map**

    키(key), 값(value)의 쌍으로 이루어진 데이터의 집합으로, 순서는 유지되지 않으며 키의 중복을 허용하지 않으나 값의 중복은 허용한다.

  - **Hashtable**

    동기화를 지원하기 때문에 HashMap보다는 느리고, 키와 값에 null 불가 <br>
    멀티 쓰레드 환경에 적합하다

  - **HashMap**

    중복과 순서가 허용되지 않고, 키와 값에 null 값이 올 수 있다. <br>
    동기화를 지원하지 않고 단일 쓰레드 환경에 적합하다

  - **TreeMap**

    Red-Black 트리 기반  <br>
    정렬된 순서대로 키와 값을 저장한다. <br>
    데이터 탐색 시 O(log N)의 시간이 걸린다. 

  -  **HashMap과 TreeMap중 무엇을 사용할지 어떻게 판단할까**

      순서가 없고 키와 값에 null을 허용하고 싶을때 HashMap을 사용할 수 있으며, 값만 null을 허용하고 정렬이 필요    할 때 TreeMap을 사용할 수 있다.

<br>

- **List**

  순서가 있는 데이터의 집합으로 데이터 중복을 허용한다.

  - **ArrayList**

  연속적인 메모리 할당으로 LinkedList 보다 검색은 빠르지만 데이터 추가 삭제가 느리다
  
  - **LinkedList**

    ArrayList의 경우 특정 인덱스의 객체를 제거할 시 나머지 모든 객체가 앞으로 1칸씩 이동한다. 객체 추가시에는 모든 객체가 뒤로 1칸씩 밀려난다. 따라서 객체의 삭제와 삽입이   빈번하게 일어 날 경우 LinkedList를 사용하는 것이 좋다.
    ArrayList는 인덱스로 데이터를 관리하지만, LinkedList의 경우 인접한 곳을 링크하여 관리한다. 중간에 데이터 삭제 시 배열을 리사이즈하거나 인덱스 업데이트 없이, 링크만 변경  하면 되기 때문에 처리속도가 빠르다. 하지만 인접한 객체에 대한 정보를 가지고 있기 때문에 메모리를 소비한다.


  - **Vector**

    ArrayList 와의 차이점은 동기화 유무다. 때문에 ArrayList 보다 객체를 추가, 삭제하는 과정이 느리다.


