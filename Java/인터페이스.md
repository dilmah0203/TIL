## Java 8 이후의 Interface의 특징

- 상수 필드를 가질 수 있다.
- 메소드 body가 없는 추상 메소드를 가진다.
- default 메소드, static 메소드를 가질 수 있다.

default 메소드란, 인터페이스에서 메소드 body를 가지는 메소드로 반드시 오버라이딩하지 않아도 되며 구현 클래스가 인터페이스의 default 메소드에 자유롭게 접근 가능하다.

## 언제 Interface를 써야 할까

추상 클래스는,

1. non-static 혹은 non-final의 필드로 객체의 상태를 바꿔야 하는 경우
2. 밀접하게 관련된 클래스끼리 코드를 공유해야할 때
3. 추상클래스의 하위 구현체 클래스들이 공통된 필드나 메소드를 공유하고, 접근제어자가 public이 아닌 경우

인터 페이스는,

1. 관련이 없는 클래스들끼리 관계를 맺어줄 때
2. 특정 데이터 타입의 동작을 지정하려고 하지만 해당 동작을 누가 구현하는지는 중요하지 않을 때
3. 다중 상속이 필요할 때

## Skeletal Implementation이란

> 추상 클래스와 인터페이스를 둘 다 쓰는 것은 가능할까?

추상 골격 구현(skeletal implementation) 클래스로 가능하다. 대표적인 예로, 컬렉션 프레임워크의 AbstractList, AbstractMap 등이 있다.

- 인터페이스로는 타입을 정의하고 필요한 일부 디폴트 메소드를 구현한다.
- 추상 골격 구현 클래스는 나머지 메소드들까지 구현한다.
- 이를 템플릿 메소드 패턴이라고 한다.


```java
public interface Vending {

    void start();
    void chooseProduct();
    void stop();
    void process();
}
```

```java
public class BaverageVending implements Vending {

    @Override
    public void start() {
        System.out.println("vending start");
    }

    @Override
    public void chooseProduct() {
        System.out.println("choose menu");
        System.out.println("coke");
    }

    @Override
    public void stop() {
        System.out.println("stop vending");
    }

    @Override
    public void process() {
        start();
        chooseProduct();
        stop();
    }
}
```

```java
public class CoffeeVending implements Vending {

    @Override
    public void start() {
        System.out.println("vending start");
    }

    @Override
    public void chooseProduct() {
        System.out.println("choose menu");
        System.out.println("cafe latte");
    }

    @Override
    public void stop() {
        System.out.println("stop vending");
    }

    @Override
    public void process() {
        start();
        chooseProduct();
        stop();
    }
}
```

두 클래스 모두 Vending 인터페이스를 구현한다. 그런데 상품을 선택하는 chooseProduct 메소드를 제외하고는 전부 다 같은 동작을 한다. 추상 골격 구현(skeletal implementation)을 이용해 중복 코드를 제거할 수 있다.

```java
public abstract class AbstractVending implements Vending {

    @Override
    public void start() {
        System.out.println("vending start");
    }

    @Override
    public void stop() {
        System.out.println("stop vending");
    }

    @Override
    public void process() {
        start();
        chooseProduct();
        stop();
    }
}
```

```java
public class BaverageVending extends AbstractVending implements Vending {

    @Override
    public void chooseProduct() {
        System.out.println("choose menu");
        System.out.println("coke");
    }
}
```

```java
public class CoffeeVending extends AbstractVending implements Vending {
  
    @Override
    public void chooseProduct() {
        System.out.println("choose menu");
        System.out.println("americano");
    }
}
```

> 왜 쓸까?

추상 골격 클래스는 private, protected가 가능하므로 오버라이딩한 메소드들을 클라이언트가 접근하지 못하도록 막을 수 있다. 그러나 인터페이스를 구현하게 되면 접근제어자가 모두 public이기 때문에 은닉이 힘들다. 또한 default 메소드에서는 하위 구현체 클래스에 대한 상태, 즉 필드에 대한 참조가 이루어질 수 없지만 추상 클래스에서는 구현체 클래스 필드에 대한 접근이 가능하다.

<br>

참고

[우아한Tech 인터페이스](https://www.youtube.com/watch?v=T1BJzC9xb0g)
