## Java 8 이후의 Interface의 특징

- 인스턴스를 생성할 수 없고 상수만 가질 수 있다.
- 메소드 body가 없는 추상 메소드를 가진다.
- default 메소드, static 메소드를 가질 수 있다.

default 메소드란, 인터페이스에서 메소드 body를 가지는 메소드를 말한다. 반드시 오버라이딩하지 않아도 되며 구현 클래스가 인터페이스의 default 메소드에 자유롭게 접근 가능하다.

> default 메소드는 왜 만들었을까?

이미 작성된 인터페이스에서 기능을 추가하려고 할 때 이것을 추상 메소드로 추가하게 된다면 모든 하위 구현체 클래스가 오버라이딩 해야 하는 문제가 있다. 하지만 deault 메소드가 있다면 그런 작업 없이 하위호환이 가능하다.

## Interface를 써야 하는 이유

- 공통의 조상을 갖지 않는 두 클래스간에 관계를 맺어줄 수 있다.

인터페이스를 사용함으로써 사용자는 내부적 구조에 대한 이해 없이 약속된 행위가 보장된다. 이러한 다형성은 추상 클래스에서도 가능하지만 상속관계의 클래스끼리만 한정적으로 이루어진다. 따라서 인터페이스는 좀 더 유연하게 다형성 적용이 가능하다.

- 다중상속이 가능하다.

> 부모 클래스에 같은 시그니처의 메소드가 있을 때, 어떤 메소드를 상속받아야 할까?

인터페이스를 통한 다중 상속에서 추상 메소드는 메소드 시그니처가 같아도 구체적인 선언부가 없기 때문에 모호함이 발생하지 않는다.

## 언제 Interface를 써야 할까

추상 클래스는,

1. non-static 혹은 non-final의 필드로 객체의 상태를 바꿔야 하는 경우
2. 밀접하게 관련된 클래스끼리 코드를 공유해야할 때
3. 추상클래스의 하위 구현체 클래스들이 공통된 필드나 메소드를 공유하고, 접근제어자가 public이 아닌 경우

인터 페이스는,

1. 관련이 없는 클래스들끼리 관계를 맺어줄 때
2. 특정 데이터 타입의 동작을 지정하려고 하지만 해당 동작을 누가 구현하는지는 중요하지 않을 때
3. 다중 상속이 필요할 때

## Skeletal Implementation이란

> 추상 클래스와 인터페이스를 둘 다 쓰는 것은 가능할까?

추상 골격 구현(skeletal implementation) 클래스로 가능하다. 대표적인 예로, 컬렉션 프레임워크의 AbstractList, AbstractMap 등이 있다.

- 인터페이스로는 타입을 정의하고 필요한 일부 디폴트 메소드를 구현한다.
- 추상 골격 구현 클래스는 나머지 메소드들까지 구현한다.
- 이를 템플릿 메소드 패턴이라고 한다.


```java
public interface Vending {

    void start();
    void chooseProduct();
    void stop();
    void process();
}
```

```java
public class BaverageVending implements Vending {

    @Override
    public void start() {
        System.out.println("vending start");
    }

    @Override
    public void chooseProduct() {
        System.out.println("choose menu");
        System.out.println("coke");
    }

    @Override
    public void stop() {
        System.out.println("stop vending");
    }

    @Override
    public void process() {
        start();
        chooseProduct();
        stop();
    }
}
```

```java
public class CoffeeVending implements Vending {

    @Override
    public void start() {
        System.out.println("vending start");
    }

    @Override
    public void chooseProduct() {
        System.out.println("choose menu");
        System.out.println("cafe latte");
    }

    @Override
    public void stop() {
        System.out.println("stop vending");
    }

    @Override
    public void process() {
        start();
        chooseProduct();
        stop();
    }
}
```

두 클래스 모두 Vending 인터페이스를 구현한다. 그런데 상품을 선택하는 chooseProduct 메소드를 제외하고는 전부 다 같은 동작을 한다.

추상 골격 구현(skeletal implementation)을 이용해 중복 코드를 제거할 수 있다.

```java
public abstract class AbstractVending implements Vending {

    @Override
    public void start() {
        System.out.println("vending start");
    }

    @Override
    public void stop() {
        System.out.println("stop vending");
    }

    @Override
    public void process() {
        start();
        chooseProduct();
        stop();
    }
}
```

```java
public class BaverageVending extends AbstractVending implements Vending {

    @Override
    public void chooseProduct() {
        System.out.println("choose menu");
        System.out.println("coke");
    }
}
```

```java
public class CoffeeVending extends AbstractVending implements Vending {
  
    @Override
    public void chooseProduct() {
        System.out.println("choose menu");
        System.out.println("americano");
    }
}
```

> 왜 쓸까?

추상 골격 클래스는 private, protected가 가능하므로 오버라이딩한 메소드들을 클라이언트가 접근하지 못하도록 막을 수 있다. 그러나 인터페이스를 구현하게 되면 접근제어자가 모두 public이기 때문에 은닉이 힘들다. 또한 default 메소드에서는 하위 구현체 클래스에 대한 상태, 즉 필드에 대한 참조가 이루어질 수 없지만 추상 클래스에서는 구현체 클래스 필드에 대한 접근이 가능하다.

<br>

참고

[우아한Tech 인터페이스](https://www.youtube.com/watch?v=T1BJzC9xb0g)