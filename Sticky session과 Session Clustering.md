## Sticky session과 Session Clustering

단일 서버 환경에서는 세션 불일치 문제를 고려하지 않아도 된다. 하지만 서비스가 커짐에 따라 한 대의 서버로 운영하는 것이 불가능해질 경우 다음과 같이 두 가지 방식이 존재한다.

- Scale up
  - 서버 자체의 성능을 업그레이드 하는 방식이지만, 확장에 한계가 있고 한 대의 서버에 부하가 집중되어 장애의 영향도가 크다.
- Scale out
  - 기존 서버만으로 용량이나 성능에 한계에 도달했을 때, 서버를 추가로 연결하는 방식으로 각 서버에 Load Balancer를 통해 트래픽을 분산하게한다. 따라서 서버 한 대에 장애가 생겨도 다른 서버에 영향을 주지 않는다. 하지만 여러 대의 서버가 세션 저장소를 독립적으로 가지기 때문에 세션 불일치 문제가 발생한다.

> Load Balancer란?
> 
> 대용량 트래픽을 **장애 없이 처리**하기 위해 여러 대의 서버에 적절히 트래픽을 분배해주는 장치

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Load%20Balancer2.png)

위 상황에서 Request A,B,C,D,E,F는 Load Balancer를 통해서 각각의 서버에 나누어진다.

만약 A 서버가 로그인 요청을 처리하게 된다면 A 서버의 세션에는 `id = "martin"`이라는 값이 저장되고 로그인 성공이라는 응답을 보낸다. 동일한 클라이언트는 다음 요청으로 유저 정보를 조회하는 `GET /users/1` 요청을 보낸다. 그러나 이 요청은 Load Balancer를 통해 C 서버로 전달 된다. C 서버의 세션에는 이 사용자가 로그인 한 사용자라는 정보가 없기 때문에, 조회 실패 후 다시 로그인하라는  로그인 페이지로 리다이렉트 될 것이다. 이러한 세션 불일치 문제를 해결하기 위한 방법 중 하나는 Sticky Session 을 사용하는 것이다.

### Sticky session

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/Sticky%20Session.png)

Sticky Session이란 말 그대로 고정된 세션을 의미한다. 첫 요청 이후의 모든 요청을 특정 서버로 고정하는 방법으로 세션 관리를 한다. 일반적으로 특정 서버로 요청 처리를 고정시키는 방법은 Cookie를 사용하거나 클라이언트의 IP tracking 하는 방식이 있다.

Sticky Session은 다음과 같은 방식으로 클라이언트와 서버의 연결을 지속시킬 수 있다.

- 클라이언트는 서버에 처음 요청을 전달한다. 그러면 Load Balancer는 서버들 중 하나에 요청을 보내 처리한다.
- 서버에서 클라이언트에 응답을 보낼 때, `Set Cookie : SERVERID=서버1` 과 같은 형태로 담당 서버 정보를 쿠키에 저장한다.
- 이후, 클라이언트가 다시 서버에 요청을 보낼때 Cookie : SERVERID=서버1 을 함께 보낸다 Load Balancer는 우선적으로 요청에 쿠키 정보가 있는지 부터 확인하고, 쿠키의 정보를 확인했다면 해당 요청은 해당 쿠키가 생성되어 있는 서버로 보내지게 된다.
- 만약 존재하지 않는 쿠키라면, 로드 밸런서의 알고리즘에 의해 선정된 다른 서버에 쿠키가 생성되어 다음에 똑같은 요청이 오면 같은 경로로 맵핑시켜 줄 수 있도록 한다.
 
동일한 사용자가 세션이 있는 해당 서버에 계속 요청을 보낼 수 있도록 지속적으로 서버 정보가 쿠키를 통해 응답에 삽입되어 보내지게 되어 클라이언트와 서버가 서로 연결을 유지할 수 있다.

**Sticky Session 문제점**

1. 특정 서버에 트래픽이 집중되는 문제

2. 세션 정보의 유실

### Session Clustering






