## @Transactional

> 트랜잭션이란? DB에 모두 반영되거나 반영되지 않아야 되는 하나의 작업 단위

작업 단위를 묶어주지 않았을 경우, DB 에서는 별개의 요청으로 받아들이기 때문에 하나의 작업 단위로 다룰 수가 없다. 애플리케이션은 커넥션 풀을 통해 커넥션 객체를 가져오고 커넥션 객체를 통해 DB에 요청을 보내는데 DB는 이러한 하나의 커넥션을 하나의 세션으로 할당해서 처리를 하게 되기 때문에 완전히 별개의 작업으로 처리가 된다.

하지만 프로그래밍 방식으로 트랜잭션 관리를 할 경우, 중복 코드가 많아지며 트랜잭션 관련 코드로 인해 관심사가 흐트러질 수 있다.

@Transactional은 **선언적 트랜잭션**이라고 하는데, 클래스나 메소드에 붙여줄 경우 해당 범위 내 메서드가 트랜잭션이 되도록 보장해주며 다음과 같은 속성을 가진다.

- 연산이 고립되어, 다른 연산과의 혼선으로 인해 잘못된 값을 가져오는 것을 방지
- 연산의 원자성이 보장되어, 연산이 도중에 실패할 경우 변경사항이 commit되지 않는다.

### @Transactional의 작동 원리와 흐름

> @Transactional이 붙은 메서드를 호출할 경우, 어떻게 동작할까?

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Transactional1.png)

서비스 객체를 상속하고 메소드를 재정의 하는데, 트랜잭션을 여는 코드를 먼저 위에서 선언하고 원래 수행하고자 했던 내용을 타겟 객체를 호출해 메소드를 실행한다. 그다음에 트랜잭션 종료 코드를 추가한다. 그렇게 재정의한 매소드가 있는 프록시 객체를 스프링 빈으로 등록한다. 타겟 객체 자체는 스프링 빈으로 등록되지 않지만 상속을 했기 때문에 부모 타입으로 주입이 다른 빈들에게도 주입이 될 수 있다.

정리하자면 빈 생성시, @Transactional 애노테이션이 있으면 프록시 객체가 빈으로 등록되며 스프링이 제공하는 선언적 트랜잭션 관리를 통해 서비스 레이어에 트랜잭션 관련된 코드를 분리할 수 있다.

<br>

참고

[우아한Tech @Transactional](https://www.youtube.com/watch?v=taAp_u83MwA)
