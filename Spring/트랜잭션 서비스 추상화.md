## 트랜잭션 서비스 추상화

"정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크가 끊기거나 서버에 장애가 생겨서 작업을 완료할 수 없다면, 그때까지 변경된 사용자의 레벨은 그대로 둘까요? 아니면 모두 초기 상태로 되돌려 놓아야 할까요?"

레벨 조정 작업은 중간에 문제가 발생해서 작업이 중단된다면 그때까지 진행된 변경 작업도 모두 취소시키도록 결정했다.

DB 서버를 다운시키거나 네트워크를 끊는 등의 강제적인 장애상황을 연출하는 건 불가능하다. 게다가 테스트는 자동화된 테스트여야 한다. 그래서 장애가 발생했을 때 일어나는 현상 중 하나인 예외가 던져지는 상황을 의도적으로 만드는 것이 낫다.

## 1. 테스트용 UserService 대역

UserService를 상속하여 테스트에 필요한 기능을 추가하도록 일부 메소드를 오버라이딩 한다.

- 먼저 테스트용으로 UserService를 상속한 클래스를 만든다. 테스트에서만 사용할 클래스라면 테스트 내부에 스태틱 클래스로 만드는 것이 간편하다.

```java
static class TestUserService extends UserService {
  private String id;

  private TestUserService(String id) {
      this.id = id;
  }

  protected void upgradeLevel(User user) {
      //지정된 id의 User 오브젝트가 발견되면 예외를 던져서 작업을 강제로 중단시킨다.
      if(user.getId().equals(this.id)) throw new TestUserServiceException();
      super.upgradeLevel(user);
  }
}

static class TestUserServiceException extends RuntimeException { //테스트용 예외
}
```

## 2. 강제 예외 발생을 통한 테스트

테스트의 목적은 사용자 레벨 업그레이드를 시도하다가 중간에 예외가 발생했을 경우, 그 전에 업그레이드 했던 사용자도 다시 원래 상태로 돌아갔는지를 확인하는 것이다.

```java
@Test
public void upgradeAllOrNothing(){
  //예외를 발생시킬 네 번째 사용자의 Id를 넣어서 테스트용 UserService 대역 오브젝트를 생성
  TestUserService testUserService = new TestUserService(users.get(3).getId());
  testUserService.setUserDao(this.userDao);
  userDao.deleteAll();
  for(User user : users) userDao.add(user);

  try{
      //TestUserService는 업그레이드 작업 중에 예외가 발생해야한다.
      testUserService.upgradeLevels();
      fail("TestUserServiceException expected");
  } catch (TestUserServiceException e){
        //예외를 잡아서 계속 진행하도록 한다. 그 외의 예외라면 테스트 실패   
  }

  //예외가 발생하기 전에 레벨 변경이 있었던 사용자의 레벨이 처음 상태로 바뀌었나 확인
  checkLevel(users.get(1), false);
}
```
이 테스트는 실패한다.

### 테스트 실패의 원인

모든 사용자의 레벨을 업그레이드하는 작업인 upgradeLevels() 메소드가 하나의 트랜잭션 안에서 동작하지 않았기 때문이다.

## 3. 트랜잭션 경계설정

DB는 완벽한 트랜잭션을 지원한다. SQL을 이용해 다중 로우의 수정이나 삭제를 위한 요청을 했을 때 일부 로우만 삭제되고 나머지는 안 된다거나, 일부 필드는 수정했는데 나머지 필드는 수정이 안되고 실패로 끝나는 경우는 없다. 

하지만 여러 개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우도 있다. 계좌이체라든가 여러 사용자에 대한 레벨 수정 작업 등이 그렇다.

문제는 첫 번째 SQL을 성공적으로 실행했지만 두 번째 SQL이 성공하기 전에 장애가 생겨서 작업이 중단되는 경우다. 이때 두 가지 작업이 하나의 트랜잭션이 되려면, 두 번째 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우에는 앞에서 처리한 SQL 작업도 취소시켜야 한다. 이런 취소 작업을 **트랜잭션 롤백**이라고 한다. 반대로 여러개의 SQL을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행 작업이 다 성공적으로 마무리됐다고 DB에 알려줘서 작업을 확정시켜야 한다. 이것을 **트랜잭션 커밋**이라고 한다.

**JDBC 트랜잭션의 트랜잭션 경계설정**

모든 트랜잭션은 시작하는 지점과 끝나는 지점이 있다. 시작하는 방법은 한가지이지만 끝나는 방법은 롤백과 커밋으로 두 가지다. 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치를 **트랜잭션의 경계**라고 부른다. JDBC의 트랜잭션은 하나의 Connection을 가져와 사용하다가 닫는 사이에서 일어난다. JDBC에서 트랜잭션을 시작하려면 자동커밋 옵션을 false로 만들어주면 된다.

```java
Connection c = dataSource.getConnection();

c.setAutoCommit(false);

try{
  PreparedStatement st1 = c.prepareStatement("update users...");
  st1.executeUpdate();

  PreparedStatement st2 = c.prepareStatement("delete users...");
  st2.executeUpdate();

  c.commit();    
}
catch(Exception e) {
    c.rollback();
}

c.close();
```

setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로 트랜잭션을 종료하는 작업을 트랜잭션 경계설정이라고 한다. 이렇게 하나의 DB 커넥션 안에서 만들어지는 트랜잭션을 로컬 트랜잭션이라고도 한다.


