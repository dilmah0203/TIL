## **2장. 테스트**

> 테스트란? 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인하는 작업이다.

### **1. 작은 단위의 테스트**

관심사의 분리라는 원리가 여기에도 적용된다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다. 이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트**라고 한다. UserDaoTest는 UserDao라는 작은 단위의 데이터 엑세스 기능만을 테스트 하기 때문에 단위 테스트라고 할 수 있다.

- UserDaoTest의 문제점
  - 수동 확인 작업의 번거로움 : add()와 get()의 값이 일치하는지 테스트 코드는 확인해주지 않는다. 단지 콘솔에 값만 출력해줄 뿐이다. 테스트의 수행은 코드에 의해 자동으로 진행되지만 결과를 확인하는 일은 사람의 책임이므로 자동으로 테스트되는 방법이라고 할 수 없다.
  - 실행 작업의 번거로움 : 만약 DAO가 수백 개가 되고 그에 대한 main() 메소드도 그만큼 만들어진다면 큰 작업이 된다.

### **2. 테스트 코드 개선**

JUnit은 테스트 프레임워크로 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다. 테스트가 main() 메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이기 때문에 일반 메소드로 옮겨야 한다. Junit 프레임워크가 요구하는 테스트 메소드 조건이 있다.

1. 메소드는 main() 대신에 public으로 선언되어야 한다.
2. 메소드에 @Test 어노테이션을 붙여주어야 한다.

```java
public class UserDaoTest {

    @Test //Junit에게 테스트용 메소드임을 알려준다
    public void addAndGet() throws SQLException { //테스트 메소드는 반드시 public으로 선언
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserDao dao = context.getBean("userDao", UserDao.class);
    }
}
```

테스트 결과를 검증하는 if/else 문장을 JUnit이 제공하는 **assertThat**이라는 스태틱 메소드를 이용해 전환할 수 있다.

```java
if (!user.getName().equals(user2.getName())) {...}
```

```java
assertThat(user2.getName(), is(user.getName()));
```

assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처라고 불리는 조건과 비교해서 일치하면 넘어가고, 아니면 테스트가 실패하게 만들어준다. is()는 매처의 일종으로 equals()로 비교해주는 기능을 가졌다.

JUnit은 예외조건 테스트를 위한 특별한 방법을 제공해준다. @Test 어노테이션의 **expected**에 테스트 메소드 실행 중에 발생하길 기대하는 예외 클래스를 넣어주면 된다. 이럴 경우 정상적으로 테스트 메소드를 마치면 테스트가 실패하고, expected에서 지정한 예외가 던져지면 테스트가 성공한다.

```java
@Test(expected=EmptyResultDataAccessException.class)
public void getUserFailure() throws SQLException {
    ...
}
```

UserDaoTest 코드를 살펴보면 다음과 같이 스프링의 애플리케이션 컨텍스트를 만드는 부분과 컨텍스트에서 UserDao를 가져오는 부분이 반복된다.

```java
ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
UserDao dao = context.getBean("userDao", UserDao.class);
```

JUnit 프레임워크는 테스트 메소드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다. @Test가 붙은 **메소드를 실행하기 전과 후**에 각각 **@Before**와 **@After**가 붙은 메소드를 자동으로 실행한다. 대신 @Before나 @After 메소드를 테스트 메소드에서 직접 호출하지 않기 때문에 서로 주고받을 오브젝트가 있다면 인스턴스 변수를 이용해야 한다.

> 픽스처란? 테스트를 수행하는 데 필요한 정보나 오브젝트

일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.
