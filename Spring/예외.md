## 4장.예외

## 1. 예외 처리

```java
try {
    ...
} catch (SQLException e) {
    e.printStackTrace();
}
```

위 코드는 예외를 잡고는 아무것도 하지 않는다. 예외 발생을 무시해버리고 정상적인 상황인 것처럼 다음 라인으로 넘어가겠다는 분명한 의도가 있는 게 아니라면 만들어서는 안 되는 코드다. 예외가 발생하면 화면에 출력하는 경우도 예외를 처리한 것은 아니다.

모든 예외는 적절하게 복구되거나 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보되어야 한다.

## 2.예외의 종류와 특징

자바에서는 `throw`를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.

### Error

- `java.long.Error`의 서브클래스
- 시스템에 비정상적인 상황이 발생했을 경우에 사용된다. 
- 애플리케이션에서는 이런 에러에 대한 처리는 신경쓰지 않아도 된다. catch블록으로 잡아봤자 대응 방법이 없기 때문이다.

### Exception과 체크 예외

- `java.lang.Exception` 클래스와 서브클래스
- 애플리케이션코드의 작업중에 예외상황이 발생했을 경우에 사용한다.
- RuntimeException을 상속하지 않은 것을 체크 예외라고 한다.
- 체크 예외가 발생할 수 있는 메소드를 사용할 경우 **반드시** 예외를 처리하는 코드를 작성해야 한다.
- `catch`또는 `throws`를 통해 처리가 되지 않으면 컴파일 에러가 발한다.
- ex) `IOException`, `SQLException`

### RuntimeException과 언체크/런타임 예외

- `java.lang.RuntimeException` 클래스의 서브 클래스
- `java.lang.RuntimeException` 를 상속한 예외들은 명시적인 **예외처리를 강제하지 않기 때문에** 언체크 에외라고 한다.
- `catch`나 `throws`를 사용하지 않아도 된다.
- 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것이다.
- ex) `NullPointException` , `IllegalArgumentException`

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Exception01.png)

## 3.예외처리 방법

### 예외 복구

- 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
- 예외로 인해 기본 작업 흐름이 불가능하면 다른 작업 흐름으로 자연스럽게 유도하는 것이다. 이런 경우 예외상황은 다시 정상으로 돌아오고 예외를 복구했다고 볼 수 있다.
- 예외가 처리됐다면 비록 기능적으로는 사용자에게 예외상황으로 비쳐도 애플리케이션에서는 정상적으로 설계된 흐름을 따라 진행되어야 한다.
- 재시도가 의미있는 경우라면 반복적으로 시도함으로써 예외상황에서 복구되게 할 수 있다.

```java
int maxretry = MAX_RETRY;
while(maxretry --> 0) {
    try {
        ...      //예외가 발생할 가능성이 있는 시도
        return;  //작업 성공
    }
    catch (SomeException e) {
        //로그 출력. 정해진 시간만큼 대기
    }
    finally {
        //리소스 반납. 정리 작업
    }
    throw new RetryFailException(); //최대 재시도 횟수를 넘기면 직접 예외 발생
}
```

### 예외처리 회피

- 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것이다. 
- 예외를 자신이 처리하지 않고 회피하는 방법
- 예외를 회피하려면 반드시 다른 오브젝트나 메소드가 예외를 대신 처리할 수 있도록 던져줘야 한다.
- throws 문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 catch 문으로 예외를 잡은 후 로그를 남기고 다시 예외를 던지는 것이다.
- 예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다.

```java
public void add() throws SQLException {
    //JDBC API
}
```

```java
public void add() throws SQLException {
    try {
     //JDBC API
    }
    catch (SQLException e) {
        //로그 출력
        throw e;
    }
}
```

### 예외 전환

- **발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다는 특징**이 있다. 예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수없기 떄문에 예외를 메소드 밖으로 던지는 것이다. 예외를 전환해서 던진다는 특징이 있다.
- 예외 전환은 두 가지 목적으로 사용된다. 
    1. 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우에 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해
    2. 예외를 처리하기 쉽고 단순하게 만들기 위해 포장(wrap) 하는 것
       - 주로 예외처리를 강제하는 체크예외를 언체크 예외인 런타임 예외로 바꾸는 경우가 이에 속한다.

예를 들어 새로운 사용자를 등록하려고 시도했을 때 아이디가 같은 사용자가 있어서 DB 에러가 발생하면 JDBC API는 SQLException을 발생시킨다. 이 경우 DAO 메소드가 SQLException을 그대로 밖으로 던져버리면, 서비스 계층 등에서는 왜 SQLException이 발생했는지 쉽게 알 방법이 없다. 이럴 땐 DAO에서 SQLException의 정보를 해석해서 DuplicateUserIdException 같은 예외로 바꾸어서 던져주는 것이 좋다. 의미가 분명한 예외가 던져지면 서비스 계층 오브젝트에는 적절한 복구 작업을 시도할 수 있다.

```java
public void add(User user) throws DuplicateUserIdException, SQLException {
    try{
        //JDBC를 이용해 user 정보를 DB에 추가하는 코드
        //그런 기능을 가진 다른 SQLException을 던지는 메소드를 호출하는 코드
    }
    catch (SQLException e) {
        //ErrorCode가 MySQL의 "Duplicate Entry"이면 예외 전환
        if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY)
            throw DuplicateUserIdException();
        else
            throw e;  //그 외의 경우는 SQLException 그대로
    }
}
```

```java
try {
    OrderHome orderHome = EJBHomeFactory.getInstanse().getorderHome();
    Order order = orderHome.fineByPrimaryKey(Integer id);
} catch (NamingException ne) { //체크예외
    throw new EJBException(ne); //언체크 예외로 던짐
} catch (SQLException se) { //체크예외 
    throw new EJBException(se); //언체크 예외로 던짐
} catch (RemoteException re) {
    throw new EJBException(re);
}
```

## 4. 예외처리 전략

### 런타임 예외의 보편화

체크예외가 일반적인 예외를 다루고, 시스템 장애 또는 프로그램상의 오류에 언체크 예외가 사용된다. 

예외를 처리하는 가장 좋은 방법은 예외상황을 미리 파악하고, 예외가 발생하지 않도록 차단하는 것이다. 또는 프로그램의 오류나 외부 환경으로 인해 예외가 발생하는 경우라면 빨리 해당 요청을 서버관리자 또는 개발자에게 통보해주는 것이 좋다. 하지만 자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치는 점점 떨어지고 있다. 그래서 대응이 불가능한 체크 예외라면 빨리 런타임 예외로 전환해서 던지는 게 낫다.

### 애플리케이션 예외

시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에의해 의도적으로 발생시키고, 반드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외도 있다. 이런 예외들을 일반적으로 애플리케이션 예외라고 한다.

예를 들어 사용자가 요청한 금액을 은행계좌에서 출금하는 기능을 가진 메소드가 있다. 현재 잔고를 확인하고, 허용하는 범위를 넘어서 출금을 요청하면 출금 작업을 중단시키고, 적절한 경고를 사용자에게 보내는 기능을 가진 메소드를 설계하는 방법이 두 가지가 있다.

1. 정상적인 출금 처리를 했을 경우와 잔고부족이 발생했을 경우 각각 리턴타입을 다르게 돌려주는 것이다.
    - 이 경우는 메소드를 호출한 쪽에서 리턴타입을 반드시 확인하여 if-else 처리를 해주어야 하므로 코드가 복잡해지고 불편할 수 있다.
2. 정상적인 흐름을 따르는 코드는 그대로 두고, 잔고 부족과 같은 예외 상황에서는 비즈니스적인 의미를 띈 예외를 던지도록 만드는 것이다.
    - 정상적인 흐름을 따르지만 예외가 발생할 수 있는 코드를 try 블록 안에 깔끔하게 정리헤두고 , 예외상황 처리는 catch 블록에 모아둘 수 있기 때문에 코드를 이해하기가 편하다.
    - 이때 사용하는 예외는 의도적으로 체크예외로 만들고 예외상황에 대한 로직을 구현하도록 강제해주는 것이 좋다.

