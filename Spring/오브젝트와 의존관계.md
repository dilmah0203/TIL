## **1장. 오브젝트와 의존관계**

### **1. 관심사의 분리**

변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 영향을 주지 않도록 **분리와 확장**을 고려한 설계를 해야한다. 즉 관심이 같은 것끼리는 모으고, 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있고 변경이 일어날 경우 수정이 간단해진다.

![img](https://github.com/dilmah0203/TIL/blob/main/Image/UserDaoTest.png)

UserDao가 사용할 ConnectionMaker 클래스를 선정하는 책임을 UserDaoTest가 담당하고 있다. D사에서 UserDao를 구매한 후 DConnectionMaker를 만들어 적용한 경우, UserDaoTest는 UserDao가 실제로 사용할 DConnectionMaker 객체를 생성하고 UserDao의 생성자를 통해 DConnectionMaker 객체를 전달한다. UserDao의 생성자는 ConnectionMaker 인터페이스 타입으로 전달받기 때문에 ConnectionMaker 인터페이스를 구현했다면 어떤 클래스로 만든 객체라도 상관 없다.


### **2. 제어의 역전(IoC)**

- 팩토리

오브젝트를 생성하는 쪽과 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용한다. 팩토리 역할을 맡은 클래스를 DaoFactory라고 하자. 팩토리의 메소드는 UserDao 타입의 오브젝트를 어떻게 만들고, 준비시킬지 결정한다.

```java
public class DaoFactory {
  public UserDao userDao() {
    ConnectionMaker connectionMaker = new DConnetionMaker();
    UserDao userDao = new UserDao(connectionMaker);
    return userDao;
  }
}
```

```java
public class UserDaoTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    UserDao dao = new DaoFactory().userDao();
    ...
  }
}

```

DaoFactory의 userDao 메소드를 호출하면 DConnectionMaker를 사용해 DB 커넥션을 가져오도록 설정된 UserDao 오브젝트를 돌려준다. UserDaoTest는 이제 UserDao가 어떻게 만들어지는지, 어떻게 초기화 되는지에 신경 쓰지 않고 팩토리로부터 UserDao 오브젝트를 받아서, 자신의 관심사인 테스트를 위해 활용하기만 하면 된다.

DaoFactory를 사용함으로써 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는데 의미가 있다.

DaoFactory에 UserDao가 아닌 다른 DAO의 생성 기능을 넣을 수도 있다.

```java
public class DaoFactory {
  public UserDao userDao() {
    return new UserDao(new DConnectionMaker());
  }

  public AccountDao accountDao() {
    return new AccountDao(new DConnectionMaker());
  }

  public MessageDao messageDao() {
    return new MessageDao(new DConnectionMaker());
  }
}
```

세 개의 DAO를 만드는 팩토리 메소드 안에 모두 new DConnectionMaker라는 부분이 반복돼서 나타난다. 이렇게 오브젝트 생성 코드가 중복되면 ConnectionMaker의 구현 클래스를 바꿀 때마다 모든 메소드를 일일이 수정해주어야 하므로 좋지 않다. 중복 문제를 해결하기 위해 다음과 같이 분리할 수 있다.

```java
public class DaoFactory {
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }

  public AccountDao accountDao() {
    return new AccountDao(connectionMaker());
  }

  public MessageDao messageDao() {
    return new MessageDao(connectionMaker());
  }

  public ConnectionMaker connectionMaker() {
    return new DConnectionMaker();
  }
}
```

- 제어권의 이전을 통한 제어관계 역전

제어의 역전이란, 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다. 일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 사용할 오브젝트를 결정하고, 결정한 오브젝트를 생성하고 메소드를 호출하는 식의 작업이 반복된다. 

제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않고, 생성하지 않는다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.

프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다. 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다. 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.

UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다. 원래 ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao에게 있었지만, 지금은 DaoFactory에게 있다. 자신이 어떤 ConnectionMaker 구현 클래스를 만들고 사용할지 결정할 권한을 DaoFactory에게 넘겼다.

### **3. 스프링의 IoC**

- 빈 : 스프링에서 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 말하며, 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.

- 빈 팩토리 : 빈의 생성과 관계설정 같은 제어를 담당하는 오브젝트

- 애플리케이션 컨텍스트 : IoC 방식을 따라 만들어진 일종의 빈 팩토리

빈 팩토리라고 말할 때는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞춘 것이고, 애플리케이션 컨텍스트라고 말할 때는 애플레케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진이라는 의미가 있다.

```java
@Configuration
public class DaoFactory {
  @Bean
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }
}
```

```java
public class UserDaoTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao = context.getBean("userDao", UserDao.class);
    ...
  }
}
```

DaoFactory를 스프링 애노테이션을 추가하여 위와 같이 만들 수 있다.

- @Configuration : 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시

- @Bean : 오브젝트 생성을 담당하는 IoC용 메소드라는 표시

애플리케이션 컨텍스트는 ApplicationContext 인터페이스를 구현하는데, ApplicationContext는 빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 애플리케이션 컨텍스트는 일종의 빈 팩토리인 셈이다.

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/ApplicationContext1.png)

DaoFactory가 UserDao를 비롯한 DAO 오브젝트를 생성하고 DB 생성 오브젝트와 관계를 맺어주는 제한적인 역할을 하는 데 반해, 애플리케이션 컨텍스트는 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다. 

@Configuration이 붙은 DaoFactory는 이 애플리케이션 컨텍스트가 활용하는 IoC 설정정보다. 애플리케이션 컨텍스트는 DaoFactory 클래스를 설정정보로 등록해두고 @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다. 클라이언트가 애플리케이션 컨텍스트의 getBean() 메소드를 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾고, 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 돌려준다.

애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점은 다음과 같다.

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다

    애플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 많아져도 애플리케이션 컨텍스트를 이용함으로써 일관된 방식으로 원하는 오브젝트를 가져올 수 있다.

- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다

- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다

    애플리케이션 컨텍스트의 getBean() 메소드는 빈의 이름을 이용해 빈을 찾아준다. 타입만으로 빈을 검색하거나 특별한 애노테이션 설정이 되어 있는 빈을 찾을 수도 있다.


### **4. 싱글톤 레지스트리와 오브젝트 스코프**

DaoFactory를 직접 사용하는 것과 @Configuration 애노테이션을 추가해서 스프링의 애플리케이션 컨텍스트를 통해 사용하는 것은 결과만 보자면 동일한 것 같다. 하지만 스프링의 애플리케이션 컨텍스트는 기존 오브젝트 팩토리와는 중요한 차이점이 있다.

```java
DaoFactory factory = new DaoFactory();
UserDao dao1 = factory.userDao();
UserDao dao2 = factory.userDao();

System.out.println(dao1);
System.out.println(dao2);
```

두 개는 각기 다른 값을 가진 동일하지 않은 오브젝트다. userDao를 매번 호출하면 계속해서 새로운 오브젝트가 만들어질 것이다.

```java
ApplicationContext context = new AnnotationConfigApplication(DaoFactory.class);

UserDao dao3 = context.getBean("userDao", UserDao.class);
UserDao dao4 = context.getBean("userDao", UserDao.class);

System.out.println(dao3);
System.out.println(dao4);
```

두 오브젝트의 출력 값은 같으므로, getBean()을 두 번 호출해서 가져온 오브젝트가 동일하다는 사실을 알 수 있다. 스프링은 여러 번에 걸쳐 빈을 요청하더라고 매번 **동일한** 오브젝트를 돌려준다는 것이다. 단순하게 getBean()을 실행할 때마다 userDao() 메소드를 호출하고, 매번 new에 의해 새로운 UserDao가 만들어지지 않는다. 왜그럴까?

스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다. 

> 왜 스프링은 싱글톤으로 빈을 만드는 것일까? 

이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다. 매번 클라이언트에서 요청이 올 때마다 오브젝트를 새로 만들어서 사용하게되면 서버에 부하가 걸릴 수 있다. 이렇게 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리다. 

**싱글톤 패턴의 한계**

- private 생성자를 갖고 있기 때문에 상속할 수 없다.

private 생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능하다. 객체 지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다. 또한 상속과 다형성 같은 객체지향의 특징이 적용되지 않는 스태틱 필드와 메소드를 사용하는 것도 역시 동일한 문제를 발생시킨다.

- 싱글톤은 테스트하기 힘들다.

싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다. 싱글톤은 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 다이내믹하게 주입하기도 힘들기 때문에 필요한 오브젝트는 직접 만들어 사용해야 한다. 이런 경우 테스트용 오브젝트로 대체하기가 힘들다.

- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.

서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다. 여러 개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.

- 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.

싱글톤의 스태틱 메소드를 이용해 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 애플리케이션 어디서든지 사용될 수 있고, 그러다 보면 자연스럽게 전역 상태로 사용되기 쉽다.

**싱글톤 레지스트리**

자바의 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, 스프링은 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 싱글톤 레지스트리다. 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있다.

- 싱글톤과 오브젝트의 상태

싱글톤은 멀티 쓰레드 환경이라면 여러 쓰레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리에 주의를 기울여야 한다. 기본적으로 싱글톤은 상태 정보를 내부에 갖고 있지 않는 무상태(stateless) 방식으로 만들어야 한다.

상태가 없는 방식으로 클래스를 만드는 경우 요청에 대한 정보나, DB나 서버로부터 생성한 정보는 어떻게 다뤄야 할까? 파라미터와 로컬 변수, 리턴 값 등을 이용하면 된다. 메소드 파라미터나 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다.

**스프링 빈의 스코프**

스프링이 관리하는 오브젝트, 즉 빈이 생성되고 존재하고 적용되는 범위를 빈의 스코프라고 한다. 빈의 스코프는 싱글톤이다. 하지만 경우에 따라서는 싱글톤 외의 스코프를 가질 수 있다. 대표적으로 프로토타입 스코프가 있다. 그 외에도 웹을 통해 새로은 HTTP 요청이 올 때 생성되는 요청 스코프가 있고, 웹의 세션과 비슷한 세션 스코프도 있다.
