## 서블릿(Servlet)이란?

서블릿이란 클라이언트의 요청을 처리하고 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술이다.

### Servlet 특징

- 클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트
- Java Thread를 이용하여 동작한다.
- MVC 패턴에서 Controller로 이용된다.
- HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다.

일반적으로 웹 서버는 정적인 페이지만을 제공한다. 여기서 웹 서버가 동적인 페이지를 제공할 수 있도록 도와주는 기술이 서블릿이다.

### Servlet 동작 방식

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Servlet0.png)

1. 클라이언트가 URL을 입력하면 HTTP Request가 Servlet Container로 전송
2. 요청을 전송받은 Servlet Container는 `HttpServletRequest`,`HttpServletResponse` 객체를 생성
3. 설정 파일(web.xml)을 참고하여 클라이언트가 요청한 URL이 어떤 서블릿에 대한 요청인지 찾는다.
4. 해당 서블릿 인스턴스 존재 유무를 확인하여 없으면 생성(init()), 있으면 서블릿 컨테이너에 쓰레드를 생성하고 service() 메소드를 호출한 후 클라이언트의 GET, POST여부에 따라 doGet() 또는 doPost()를 호출
5. doGet() or doPost() 메소드는 동적 페이지를 생성한 후 `HttpServletResponse`객체에 응답을 보냄
6. 응답을 처리한 `HttpServletRequest`, `HttpServletResponse` 두 객체는 소멸

> 서블릿은 왜 생성만 하고 소멸시키는 동작을 하지 않을까?

서블릿이 싱글톤으로 관리되기 때문이다. 서블릿은 소멸하지 않고 있다가 다음에 같은 요청이 들어오면 서블릿 컨테이너에 의해 또 호출되어 사용된다.

## Servlet Container(서블릿 컨테이너)

서블릿 컨테이너는 서블릿 생명주기를 관리하는 컨테이너다. 서블릿 컨테이너는 클라이언트의 요청을 받아주고 응답을 할 수 있게 웹 서버와 통신하며 대표적인 예로 톰캣이 있다.

**Servlet 컨테이너의 역할**

- 웹 서버와의 통신 지원
  - 서블릿 컨테이너는 서블릿과 웹 서버가 통신할 수 있게 도와주어 복잡한 과정을 생략할 수 있게 해준다. 그래서 개발자는 비즈니스 로직에 대해서만 신경쓸 수 있게 도와준다.
- 서블릿 생명주기 관리
  - 서블릿 클래스를 로딩하여 초기화 메소드를 호출하고, 요청이 들어오면 적절한 서블릿 메소드를 호출한다.
- 멀티쓰레드 지원 및 관리
  - 서블릿 컨테이너는 요청이 올 때마다 새로운 자바 쓰레드를 생성하고, HTTP 서비스 메소드를 실행하고 나면 쓰레드를 자동으로 죽게된다. 

**Servlet 생명주기**

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/Servlet%20Lifecycle.png)

1. 클라이언트의 요청이 들어오면 서블릿 컨테이너는 해당 서블릿이 메모리에 있는지 확인하고, 없을 경우 init() 메소드를 호출하여 적재한다. init()메소드는 처음 한번만 실행된다.
2. init()이 호출된 후 클라이언트의 요청에 따라 service() 메소드를 통해 요청에 대한 응답이 분기된다.
3. 서블릿 컨테이너가 서블릿에 종료 요청을 하면 destroy()메소드가 호출되는데 마찬가지로 한번만 실행된다.

## 프론트 컨트롤러 패턴

![img3](https://github.com/dilmah0203/TIL/blob/main/Image/Servlet3.png)

위처럼 요청 경로마다 서블릿을 정의해주는 것은 핸들러마다 공통 로직이 중복된다는 문제가 있다. 공통된 로직을 앞단에 두어 모든 클라이언트의 요청을 처리하게 두면 어떨까?

![img4](https://github.com/dilmah0203/TIL/blob/main/Image/Servlet4.png)

개발자는 공통된 로직을 매번 작성하지 않아도 되어 핵심 로직에만 집중할 수 있을 것이다. 스프링은 프론트 컨트롤러 패턴을 따르고 이를 DispatcherServlet이 담당한다. DispatcherServlet은 클라이언트의 요청을 먼저 받아 필요한 처리를 한 뒤, 개발자가 구현한 요청에 맞는 핸들러에게 요청을 전달하고 해당 핸들러의 실행 결과를 Response 형태로 만드는 역할을 한다.

## Dispatcher-Servlet(디스패처 서블릿)이란?

디스패처 서블릿은 **HTTP 프로토콜로 들어오는 요청을 가장 먼저 받아 공통적인 작업을 먼저 처리한 후에 해당 요청을 처리해야 하는 컨트롤러를 찾아서 작업을 위임해주는 프론트 컨트롤러이다.**

클라이언트로부터 어떠한 요청이 오면 톰캣과 같은 서블릿 컨테이너가 요청을 받게 된다. 그리고 이 모든 요청을 프론트 컨트롤러인 디스패처 서블릿이 가장 먼저 받고, 공통 작업을 처리 후 적절한 컨트롤러를 찾아서 위임한다. 과거에는 모든 서블릿을 URL 매핑을 위해 web.xml에 모두 등록해주어야 했지만 Dispatcher-Servlet이 해당 어플리케이션으로 들어오는 모든 요청을 핸들링해주고 공통 작업을 처리해주어 편리해졌다. 컨트롤러를 구현해두기만 하면 Dispatcher-Servlet이 알아서 적합한 컨트롤러로 위임해준다.

### Dispatcher-Servlet의 동작 과정

![img5](https://github.com/dilmah0203/TIL/blob/main/Image/Dispatcher-Servlet.png)

1. 클라이언트의 요청을 Dispatcher-Servlet이 받는다.
2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾는다.
3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달한다.
4. 핸들러 어댑터는 컨트롤러로 요청을 위임한다.
5. 비즈니스 로직을 처리한다.
6. 컨트롤러는 값을 반환한다.
7. 핸들러 어댑터가 반환값을 처리한다.
8. 서버의 응답을 클라이언트로 반환한다.

