## 스프링 트랜잭션

**JDBC api에서의 트랜잭션**

```java
public void upgradeLevels() throws Exception {
  // (1) DB Connection 생성
  // (2) 트랜잭션 시작
  try {
    // (3) DAO 메소드 호출
    // (4) 트랜잭션 커밋
  }
  catch(Exception e) {
    // (5) 트랜잭션 롤백
    throw e;
  }
  finally {
    // (6) DB Connection 종료
  }
}
```

문제점

- 깔끔하던 Service 코드가 복잡해짐

- 데이터 엑세스 기술에 의존적인 코드

- 비즈니스 로직과는 다른 관심사의 일을 수행

스프링은 다음 세 가지 기술을 이용하여 위의 문제점을 해결해준다.

- 트랜잭션 동기화
- 트랜잭션 추상화
- 선언적 트랜잭션

1. 트랜잭션 동기화

Spring JDBC에서 제공하는 DataSourceUtils 클래스의 getConnection() 메소드를 사용하여 트랜잭션을 생성한다. 이 트랜잭션은 thread-safe한 TransactionSynchronizationManager에 저장한다. TransactionSynchronizationManager에 저장된 Connection이 존재한다면 JdbcTemplate이 쿼리를 날릴 때 저장된 Connection을 가져온다. 덕분에 쿼리 모두 하나의 local transaction으로 관리할 수 있게 되고 Connection 파라미터를 받지 않게 되었다. 마지막으로 트랜잭션이 종료되는 지점에서 Connection을 release(닫아) 해줌으로써 Connection을 제거해준다.

파라미터로 Connection을 받는 문제는 해결했지만, 결론적으로 JdbcTemplate이 DataSourceUtils를 사용하여 Connection을 가져오거나 생성한다. 아직 **데이터 접근 기술에 의존적**이다.

2. 트랜잭션 추상화

위 문제가 발생하는 이유는 데이터 접근 기술마다 DB와의 연결 방법이 다르기 때문이다. 하지만 가져오는 트랜잭션 객체만 다를 뿐 구현 방식에 상관 없이 동일한 임무를 수행하는 구현체들에 대한 추상화가 가능하다. 스프링은 PlatformTransactionManager라는 인터페이스를 사용해 각 구현체들이 트랜잭션을 가져오는 방식을 추상화했다.

하지만 비즈니스 로직과는 다른 관심사의 일을 하고 있는 문제는 해결하지 못했다.

3. 선언적 트랜잭션

그래서 스프링은 선언적 트랜잭션 @Transactional 어노테이션을 이용해서 트랜잭션을 생성, 종료하는 일을 비즈니스 로직과 분리하게 도와준다.

```java
//4번 탐색
public interface Service {

    //3번 탐색
    void method1();
}

//2번 탐색
public class ServiceImpl implements Service {

    //1번 탐색
    public void method1() {
        //구현
    }
}
```

선언적 트랜잭션은 타겟 오브젝트의 메소드부터 탐색한다. 따라서 Service를 상속받는 모든 클래스와 메소드에 동일한 트랜잭션 속성 부여가 가능하다.

## 스프링 트랜잭션 속성

스프링은 트랜잭션 경계설정 뒤에 전파(propagation), 고립(ioslation), 읽기동작(read-only), 타임아웃(timeout)이라는 속성을 지정할 수 있다.

- propagation : 트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정

  - REQUIRED : 기본 속성, 트랜잭션이 있으면 참여하고 없으면 새로 시작
  - REQUIRES_NEW : 항상 새로운 트랜잭션을 시작하고 진행 중인 트랜잭션이 있다면 보류
  - SUPPORTS : 이미 트랜잭션이 있으면 참여하고 그렇지 않으면 트랜잭션 없이 진행
  - NESTED : 이미 진행 중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다. 부모 트랜잭션 커밋, 롤백엔 영향을 받지만 자신의 커밋, 롤백은 부모 트랜잭션에 영향을 주지 못함
  - NEVER : 트랜잭션을 사용하지 않는다. 트랜잭션에 존재하면 예외 발생
  - NOT_SUPPROTED : 트랜잭션을 사용하지 않는다. 트랜잭션이 있다면 보류

- isolation : 여러 트랜잭션이 진행될 때 트랜잭션의 작업 결과를 타 트랜잭션에게 어떻게 노출할지 결정

  - DEFAULT : 사용하는 DB 드라이버의 기본 설정
  - READ_UNCOMMITTED : 커밋하지 않은 정보는 읽을 수 없음
  - REPEATABLE_READ : 다른 트랜잭션이 읽은 정보를 수정 반영 x
  - SERIALIZABLE : 트랜잭션 순차 진행

- readOnly : 트랜잭션 내에서 데이터를 조작하려는 시도를 막음

- timeout : 트랜잭션을 수행하는 제한 시간 설정
