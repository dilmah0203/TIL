## 인덱스(index)란 

**index**는 DB 테이블의 **검색 속도를 향상** 시켜주는 자료구조이다. DB의 index는 책의 색인과 같다. 테이블의 모든 데이터를 순차적으로 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕는다.

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Index.png)

index를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE, DELETE의 성능이 함께 향상된다. 이유는 해당 연산을 수행하기 위해 해당 대상을 검색해야만 작업을 할 수 있기 때문이다.

```sql
//이름을 업데이트 해주기 위해서는 WHERE절을 검색해야 한다.
UPDATE USER SET NAME = 'JuSeon' WHERE NAME = 'Lee';
```

만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색해야 한다. 전체 탐색은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

DBMS는 index를 최신 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 index가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.

- INSERT: 새로운 데이터에 대한 인덱스를 추가
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가

### 인덱스의 장점과 단점

- 장점
  - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
    - 조건 검색 WHERE 절의 효율성
    - 정렬 ORDER BY 절의 효율성
    - MAX, MIN의 효율적인 처리

- 단점
  - 인덱스도 하나의 DB 객체로 인덱스를 관리하기 위한 저장공간이 필요하다.
  - 인덱스를 잘못 사용할 경우 오히려 성능저하를 일으킬 수 있다.

> 인덱스는 언제 사용하면 안 될까?

만약 CREATE, DELETE, UPDATE가 빈번한 속성에 index를 걸게 되면 index의 크기가 커져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. UPDATE와 DELETE는 기존의 index를 삭제하지 않고 사용하지 않음 처리를 하기 때문에 UPDATE와 DELETE가 빈번하게 발생된다면 성능이 떨어지게 된다.

### 인덱스 자료구조

- 페이지 : 데이터가 저장되는 단위
- Full Table Scan : 순차적으로 접근하기 때문에 접근 비용이 감소한다. 적용 가능한 인덱스가 없는 경우, 인덱스 처리 범위가 넓은 경우, 크기가 작은 테이블에 엑세스하는 경우에 사용. DB가 인덱스를 적용하여도 성능상 별로 이점이 없다고 생각될 때 사용할 수 있다.

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/BinarySearch%20Tree.png)

**Binary Serch Tree(이진 탐색 트리)**

- 이진 탐색
  - 탐색에 소요되는 시간복잡도는 O(log n)으로 빠름
- 연결 리스트
  - 자료 입력, 삭제에 필요한 시간복잡도는 O(1)로 빠르지만 탐색하는데 O(n)

이진 탐색 트리는 이 둘의 장점이 합쳐서 만들어진 자료구조이다. 균형 잡힌 이진 탐색 트리의 경우 시간복잡도가 O(log n)이 되지만, 균형이 잡히지 않은 이진 탐색의 경우 O(n)으로 이진탐색의 장점을 가졌다고 보기 어렵다. 이러한 단점을 극복하기 위해 여러 자료구조가 나왔고 그중에 B-Tree가 있다.

**B-Tree(Balanced-Tree)**

- 트리 높이가 같다.
- 자식 노드를 2개 이상 가질 수 있다.
- 기본 DB 인덱스 구조










