## 인덱스(index)란 

index는 DB 테이블의 검색 속도를 향상 시켜주는 자료구조이다. DB의 index는 책의 색인과 같다. 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕는다.

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Index.png)

index를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE, DELETE의 성능이 함께 향상된다. 이유는 해당 연산을 수행하기 위해 해당 대상을 조회해야만 작업을 할 수 있기 때문이다.

```sql
//Lee라는 이름을 업데이트 해주기 위해서는 JuSeon을 조회해야 한다.
UPDATE USER SET NAME = 'JuSeon' WHERE NAME = 'Lee';
```

만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색해야 한다. 전체 탐색은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

DBMS는 index를 최신 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 index가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.

- INSERT: 새로운 데이터에 대한 인덱스를 추가
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가

## 인덱스의 장점과 단점

- 장점
  - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
    - 조건 검색 WHERE 절의 효율성
    - 정렬 ORDER BY 절의 효율성
    - MAX, MIN의 효율적인 처리

- 단점
  - 인덱스를 관리하기 위한 저장공간이 필요하다.
  - 인덱스를 잘못 사용할 경우 오히려 성능저하를 일으킬 수 있다.

> 인덱스는 언제 사용하면 안 될까?

만약 CREATE, DELETE, UPDATE가 빈번한 속성에 index를 걸게 되면 index의 크기가 커져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. UPDATE와 DELETE는 기존의 index를 삭제하지 않고 사용하지 않음 처리를 하기 때문에 UPDATE와 DELETE가 빈번하게 발생된다면 성능이 떨어지게 된다.

## 인덱스의 자료구조

인덱스를 구현하기 위한 다양한 자료구조가 있다.

### 해시 테이블(Hash Table)

Hash Table은 (key, value)로 데이터를 저장하는 자료구조이며 빠른 데이터 검색에 유용하다. Hash Table은 key값을 이용하여 고유한 index를 생성하고 그 index에 저장된 값을 꺼내온다.

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/Hash%20Table.png)

Hash Table 기반의 DB 인덱스는 (데이터= 컬럼의 값, 데이터의 위치)를 (key, value)로 사용하여 컬럼의 값으로 생성된 해시 값을 통해 인덱스를 구현한다. Hash Table의 시간복잡도는 O(1)이기 때문에 매우 빠른 검색을 지원한다.

하지만 Hash Table이 사용되는 경우는 제한적이다. 이유는 해시가 등호(=) 연산에만 특화되어있기 때문에 부등호 연산이 자주 사용되는 DB 검색을 위해서는 Hash Table은 적합하지 않다.

### B+Tree

B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+Tree는 모든 노드에 데이터(Value)를 저장했던 B-Tree와 다른 특성을 가지고 있다.

![img3](https://github.com/dilmah0203/TIL/blob/main/Image/B%2BTree.png)

B+Tree는 오직 leaf node에만 데이터를 저장하고 leaf node가 아닌 node에서는 자식 포인터만 저장한다. 그리고 leaf node끼리는 Linked list로 연결되어있다. B+Tree에서는 반드시 leaf node에만 데이터가 저장되기 때문에 중간 node에서 key를 올바르게 찾아가기 위해서 key가 중복될 수 있다. 

> 장점이 뭐가 있을까?

1. leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다. 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다. 

2. Full scan을 하는 경우 B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다. 반면 B-Tree는 모든 node를 확인해야 한다. 

B-Tree의 경우 최상의 경우 특정 key를 root node에서 찾을 수 있지만, B+Tree의 경우 반드시 특정 key에 접근하기 위해서 leaf node까지 가야 하는 단점이 있다.  
