## 세션 불일치 문제의 배경

단일 서버 환경에서는 세션 불일치 문제를 고려하지 않아도 된다. 하지만 서비스가 커짐에 따라 한 대의 서버로 운영하는 것이 불가능해질 경우 다음과 같이 두 가지 방식이 존재한다.

- Scale up
  - 서버 자체의 성능을 업그레이드하는 방식이지만, 확장에 한계가 있고 한 대의 서버에 부하가 집중되어 장애의 영향도가 크다.
- Scale out
  - 기존 서버만으로 용량이나 성능에 한계에 도달했을 때, 서버를 추가로 연결하는 방식으로 각 서버에 Load Balancer를 통해 트래픽을 분산하게 한다. 따라서 서버 한 대에 장애가 생겨도 다른 서버에 영향을 주지 않는다. 하지만 여러 대의 서버가 세션 저장소를 독립적으로 가지기 때문에 세션 불일치 문제가 발생한다.

> Load Balancer란?
> 
> 대용량 트래픽을 **장애 없이 처리**하기 위해 여러 대의 서버에 적절히 트래픽을 분배해 주는 장치

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Session.PNG)

로그인하려는 상황을 가정해 보자. 사용자의 로그인 요청을 받은 A 서버는 사용자의 로그인 정보가 담긴 세션이 저장되고 로그인이 성공했다는 응답을 사용자에게 전달한다. 동일한 사용자는 다음 요청으로 유저 정보를 조회하는 `GET /users/1` 요청을 보낸다. 그러나 이 요청은 Load Balancer를 통해 C 서버로 전달된다. C 서버의 세션에는 이 사용자가 로그인 한 사용자라는 정보가 없기 때문에, 조회 실패 후 다시 로그인하라는  로그인 페이지로 리다이렉트 될 것이다. 이러한 세션 불일치 문제를 해결하기 위한 방법 중 하나는 Sticky Session 을 사용하는 것이다.

## Sticky session

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/Sticky%20session.PNG)

Sticky Session은 사용자의 세션을 처음 생성한 서버가 해당 사용자의 작업을 담당하여 고정된 세션만 사용한다. 즉 `user1`이 A 서버에 처음 로그인 요청을 하여 세션을 생성하였다면, 앞으로의 모든 `user1`의 요청은 A 서버에만 보내지게 된다. 항상 동일한 서버에 요청을 하는 것이 아닌 클라이언트의 요청에 쿠키가 존재하는지 확인 후 요청 작업이 이루어진다. 만약 쿠키가 존재하지 않는다면 기존 로드밸런싱 방법에 의해 요청이 이루어진다.

### Sticky Session의 단점

세션 정합성 문제를 해결할 수 있지만 특정 서버에 장애가 발생하면 해당 서버로 요청을 보내는 사용자의 세션 정보를 잃어버릴 수 있다. Load Balancer는 장애가 발생된 서버를 제외하고 나머지 서버로 요청을 보내게 되는데, 결국 다시 로그인해야 하는 상황이 발생한다. 또한 다운된 서버가 구동되더라도 이미 다른 서버로 분산된 세션 정보가 돌아오지 않아 다른 특정 서버에 트래픽이 집중될 수 있다.

## Session Clustering

클러스터링은 여러 대의 서버들이 연결되어 하나의 시스템처럼 동작하는 것을 의미하며 Session Clustering 방식은 세션이 생성과 변경 등에 작업이 있을 때마다 해당 세션이 속한 모든 서버에 세션 정보를 전파하여 정합성을 해결한다.

WAS에 따라서 Session Clustering 방식이 다른데, 스프링 부트의 내장 WAS인 Tomcat의 Session Clustering 방식은 다음과 같다.

![img3](https://github.com/dilmah0203/TIL/blob/main/Image/Session%20Clustering.PNG)

즉 Tomcat은 Session Clustering을 구현하는 방법으로 all-to-all 세션 복제 방식을 사용하며, 해당 방식은 하나의 세션 저장소에 변경이 발생하면 변경된 사항이 다른 모든 세션에 복제된다.

![img4](https://github.com/dilmah0203/TIL/blob/main/Image/Session%20Clustering2.PNG)

사용자의 세션이 새로 생성되거나 업데이트될 때마다 Tomcat에서 DeltaManager가 다른 모든 서버에 해당 세션의 정보를 복제한다. 그렇게 되면 사용자의 요청이 처음 세션을 생성한 서버가 아닌 다른 서버로 보내졌어도 모든 서버에는 사용자의 세션 정보를 가지고 있어 세션 불일치 문제가 발생하지 않는다.

### Session Clustering의 단점

데이터가 변경될 때마다 세션을 전파하는 작업을 수행하므로 서버의 수가 늘어날수록 오버헤드가 크다. 그렇기 때문에 위 공식 문서 내용과 같이 4대 이상의 대규모 클러스터는 권장되지 않는다. 마찬가지로 서버 수에 비례하여 트래픽이 증가하므로 성능 저하가 생길 수 있다. 또한 세션 데이터 복제 작업 중에 모든 서버에 세션이 전파되기까지의 시간차로 인하여 세션 불일치 문제가 발생할 가능성이 존재한다.

## Session Storage

Session Storage 방식은 독립된 세션 저장소를 구성하여 해당 저장소에 세션 데이터를 저장하고, 다른 서버들이 이러한 독립된 세션 저장소에서 세션 데이터를 읽어오는 방식이다.

![img5](https://github.com/dilmah0203/TIL/blob/main/Image/Session%20Storage.PNG)

Session Storage가 분리되면 서버가 늘어나도 외부 저장소의 정보만 각각의 서버에 입력해 주면 데이터를 읽어올 수 있다. 그렇기 때문에 Sticky Session의 문제점인 특정 서버로 트래픽이 몰리는 문제가 발생하지 않는다. 또한 독립된 저장소에서 세션을 공유하므로 세션이 재설정되어도 세션 저장소의 데이터만 수정하면 되어 WAS 간 불필요한 네트워크 통신 과정을 진행하지 않아도 된다. 저장소로는 MySQL, OracleDB 등 RDBMS과 Redis와 Memcached 같은 In memory DB를 사용한다.

### Session Storage의 단점

하나의 독립된 세션 저장소에서 세션 정보를 저장하고 있기 때문에 해당 저장소가 다운되면 모든 서버가 세션을 공유 받을 수 없게 된다. 그래서 동일한 세션 저장소를 하나 더 구성하여 복제해야 할 필요가 있다.

<br>

참고

https://tomcat.apache.org/tomcat-8.5-doc/cluster-howto.html

[우아한Tech Sticky session & Session Clustering](https://www.youtube.com/watch?v=gzKf2BTZToQ)
