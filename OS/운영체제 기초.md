## 운영체제와 커널

- 운영체제란 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층
- 컴퓨터 시스템의 **자원을 효율적으로 관리**
  - 중앙 처리 장치(CPU), 기억장치, 입출력 장치 등의 효율적 관리
  - 실행중인 프로그램들에게 CPU를 번갈아 할당, 메모리 공간을 적절히 분배
- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공

그렇다면 운영체제는 어디에 위치해 있길래 모든 시스템 자원을 관리하고 제어하는 것일까? 사실 운영체제도 디스크에 저장되어 있다가 실행할 시기가 오면, 메모리에 올라와서 실행되어 사용자 인터페이스를 제공해준다. 운영체제는 우선순위가 높을 뿐 하나의 소프트웨어이기 때문이다.

하지만 운영체제의 용량은 매우 크다. 그렇기 때문에 메모리에 모두 올라와 실행하기에는 비효율적이다. 그렇다면 어떻게 해야할까? 정말 필요한 것들만 메모리에 올리면 된다. 이렇게 메모리에 올라간 운영체제의 특정 부분을 커널이라고 한다.

커널은 아래와 같은 기능을 수행한다.

- 프로세스 관리 및 CPU 스케줄링
  - 프로세스마다 CPU를 사용할 수 있는 시간을 분배 및 관리한다. 
- 한정된 메모리를 어떻게 쪼개어 쓸지 메모리 관리
- 각기 다른 입출력장치와 컴퓨터 간에 어떻게 정보를 주고 받을지 입출력 관리
- 디스크에 파일을 어떻게 보관할지 파일관리

![img](https://github.com/dilmah0203/TIL/blob/main/Image/computer%20architecture.png)

**CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터**를 **프로그램 카운터**(PC)라고 한다. 즉, CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리하게 된다. 메모리에는 사용자 프로그램들과 운영체제가 같이 올라가 수행된다. 이때 CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행한다. PC가 운영체제를 가리키고 있으면 커널모드, PC가 프로그램을 가리키고 있으면 사용자모드 이다.

CPU가 수행하는 명령에는 메모리에서 자료를 읽어와 CPU에서 계산하고 결과를 메모리에 쓰는 **일반명령**과 보안이 필요한 명령으로 입출력 장치, 타이머등에 접근하는 **특수명령**이 있다. CPU내의 모드비트를 이용하여 시스템은 실행가능성을 체크한다. 다만 사용자 프로그램을 하다가 특수명령이 필요할때가 생기게 된다. 이때는 사용자 프로그램이 스스로 특수명령을 실행할 수 없기에 **시스템 콜**(System Call)이라는 서비스 요청을 하여 운영체제에게 대행을 요구한다. 

시스템 콜을 하게 되면 운영체제는 사용자 프로그램의 코드가 아닌 커널 영역에 정의된 시스템 콜 처리 코드를 수행하게 된다. 즉, 커널은 시스템 콜이 발생하면 CPU를 커널 모드로 전환하여 자신들의 작업을 수행한다.

## 프로그램의 실행

**프로그램이 실행되고 있다는 것**은 **디스크에 존재하던 실행파일이 메모리에 적재**되거나 **프로그램이 CPU를 할당 받고 명령을 수행하고 있는 상태**라는 것이다.

![img](https://github.com/dilmah0203/TIL/blob/main/Image/program.png)

프로그램은 보통 실행파일 형태로 하드디스크에 저장되고 실행파일을 실행시키면 메모리로 올라가 프로세스가 된다. 메모리로 올라가기 전, 가상 메모리가 되는 과정을 거치게 되는데 가상메모리의 주소 공간은 코드, 데이터, 스택 등으로 구성된다. 각 프로그램마다 이러한 가상 메모리 주소공간을 별도로 가지고 이것을 물리적인 메모리로 올려 실행시키게 된다. 물리적인 메모리 공간의 커널은 처음 부팅 시 항상 상주하여 올라가있지만 사용자 프로그램들은 실행시키면 주소공간이 생겼다가 프로그램 종료 시 사라지게 된다. 

![img](https://github.com/dilmah0203/TIL/blob/main/Image/program2.png)

운영체제의 커널 또한 코드, 데이터, 스택 공간을 가진다. **커널의 코드 영역**에는 CPU, 메모리 등의 자원을 관리 하기 위한 부분과 시스템 콜 및 인터럽트를 처리하는 부분을 포함한다. **커널의 데이터 영역**에는 각종 자원(CPU, 메모리, 프로그램 등)을 관리하기 위한 자료구조가 저장된다. **커널의 스택 영역**에는 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리한다. 

## 시분할(time sharing) 처리 방식

- 현대 운영체제에서 사용하는 방식이다.
- 여러 작업을 수행할 때 CPU를 사용하는 시간을 잘개 쪼개서, 여러 개의 응용 프로그램이 동시에 실행하는 기법
- 다중 사용자를 지원하고, 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐
- 멀티 태스킹
  - 단일 CPU에서, 여러 응응 프로그램이 동시에 실행되는것처럼 보이도록 하는 시스템
- 멀티 프로그래밍
  - 최대한 많은 CPU를 활용하도록 하는 시스템
- 멀티 프로세싱
  - 여러 CPU에서 하나의 응용 프로그램을 병렬로 실행해서 속도를 높이는 기법

## 인터럽트

CPU는 매번 프로그램 카운터가 가리키고 있는 지점의 명령을 하나씩 수행하고 나서, 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되어있는지 체크한다. 인터럽트 라인 체크를 통해 인터럽트가 발생했다면 CPU는 현재 수행중인 프로세스를 멈추고 CPU를 운영체제가 회수하여 인터럽트 처리루틴으로 이동하여 인터럽트 처리를 수행한다. 인터럽트의 처리를 마치고 나면 인터럽트가 발생하기 직전의 프로세스에게 CPU의 제어권이 다시 넘어간다.

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/Interrupt%20Service%20Routine.png)

사용자와 운영체제는 시스템 자원을 공유하기 때문에 사용자에 제한을 두지 않으면 메모리 내 주요 자원을 망가뜨릴 위험이 있다. 따라서 사용자의 자원 접근을 막는 보호 장치가 필요하고, 이 것이 이중 동작 모드이다. 이중 동작 모드는 사용자가 접근할 수 없는 커널 모드, 접근할 수 있는 사용자 모드로 나뉜다.

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/Interrupt%20Service%20Routine2.png)

프로세스는 사용자 모드에서 실행되다가 운영체제에게 시스템 사용을 요청하면 커널 모드로 전환되어 요청된 시스템을 실행한 후 다시 사용자 모드로 전환한다. (시스템 콜) 

시스템 콜은 하나의 인터럽트로 취급된다. 커널 모드와 사용자 모드를 구분하기 위해서는 mode bit가 사용되며 0이 커널 모드, 1이 사용자 모드이다. 운영체제는 일부 명령들을 특권 명령으로 지정하고 커널 모드에서만 실행되게 하며 사용자 모드에서 실행하려고 하면 trap을 건다.

## 동기식 입출력과 비동기식 입출력

- 동기식 입출력
  - I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에게 넘어감
- 비동기식 입출력
  - I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감
 
두 경우 모두 I/O의 완료는 인터럽트로 알려준다.
 









