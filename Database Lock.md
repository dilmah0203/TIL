## Database Lock

> 데이터베이스에 Lock이 왜 필요할까?

트랜잭션들이 **동시에** 수행될 때, **일관성**을 해치지 않도록 데이터 접근을 제어한다.

### Lock의 종류

동시성 제어는 어떻게 할까? Lock에는 크게 낙관적 잠금(Optimisstic Lock)과 비관적 잠금(Pessimistic Lock)이 있다.

- 낙관적 잠금 
    - 데이터 갱신 시 **경합이 발생하지 않을 것**이라고 봄
    - 동시 업데이트가 거의 없는 경우 
- 비관적 잠금
    - 데이터를 **동시에 수정 할 가능성이 높다**고 봄
    - 동시 업데이트가 빈번한 경우

### 비관적 잠금 연산의 종류

1. 공용(shared) Lock

read 연산 실행 가능, write 연산 실행 불가능
데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있다.

2. 베타(exclusive) Lock

read 연산과 write 연산 모두 실행 가능
베타 Lock 연산을 실행한 트랜잭션만 해당 데이터에 대한 독점권을 가짐

### Lock으로 발생할 수 있는 문제점

1. 블로킹(Blocking)

블로킹이란 Lock들의 경합이 발생하여 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태로, 데이터에 대해 하나의 트랜잭션이 **베타 Lock**을 걸면 다른 트랜잭션들은 Lock을 걸지 못하고 **대기**해야하기 때문에 발생한다. 트랜잭션이 commit 혹은 rollback시에 블로킹은 풀린다.

-블로킹 해결방안
- 트랜잭션을 짧게 정의
- 같은 데이터를 갱신하는 트랜잭션은 동시에 수행되지 않도록 설계
- LOCK TIMEOUT을 이용하여 잠금해제 시간을 조절

2. 데드락(Deadlock)

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Deadlock.png)

트랜잭션1이 리소스1에 대해 베타 Lock을 걸고, 트랜잭션2가 리소스2에 공유 Lock을 걸었다고 가정하자. 트랜잭션2가 리소스1에게 공유 Lock을 걸어야 하는데 이미 베타 Lock이 걸려있어 대기하게된다. 또한 트랜잭션1도 트랜잭션2가 리소스2에 걸어놓은 공유 Lock 때문에 대기할 수 밖에 없다. 트랜잭션이 서로가 서로를 기다리게 되어 무한 대기 상태에 빠지는 것이 Deadlock이다.

- 데드락 해결방안
    - 트랜잭션 진행방향을 같은방향으로 처리하게되면 블로킹 문제가 발생하지만, 데드락 발생 확률이 줄어든다.
    - 트랜잭션 처리속도를 최소화
    - LOCK TIMEOUT을 이용하여 잠금해제 시간을 조절
